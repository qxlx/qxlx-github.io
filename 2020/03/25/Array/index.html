<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Array"><meta name="keywords" content=""><meta name="author" content="qxlx"><meta name="copyright" content="qxlx"><title>Array | i</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Array"><span class="toc-number">1.</span> <span class="toc-text">Array</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#283-移动零"><span class="toc-number">1.1.</span> <span class="toc-text">283.移动零</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-空间最优，操作局部优化（双指针）"><span class="toc-number">1.1.1.</span> <span class="toc-text">-1.空间最优，操作局部优化（双指针）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-一次loop"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.一次loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-滚雪球"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.滚雪球</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-爬楼梯"><span class="toc-number">1.2.</span> <span class="toc-text">70.爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-暴力破解"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.暴力破解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-动态规划"><span class="toc-number">1.2.2.</span> <span class="toc-text">-2.动态规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-container-with-most-water"><span class="toc-number">1.3.</span> <span class="toc-text">11.container-with-most-water</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-枚举"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-左右夹逼"><span class="toc-number">1.3.2.</span> <span class="toc-text">-2.左右夹逼</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-移除元素"><span class="toc-number">1.4.</span> <span class="toc-text">27.移除元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-拷贝覆盖"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.拷贝覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-交换移除"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.交换移除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-双指针"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.双指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-双指针-要删除的元素很少时"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.双指针-要删除的元素很少时</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-搜索插入位置"><span class="toc-number">1.5.</span> <span class="toc-text">35.搜索插入位置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-二分查找"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.二分查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-两数之和"><span class="toc-number">1.6.</span> <span class="toc-text">1.两数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-暴力破解-1"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.暴力破解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-哈希表"><span class="toc-number">1.6.2.</span> <span class="toc-text">-2.哈希表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-三数之和"><span class="toc-number">1.7.</span> <span class="toc-text">15.三数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-暴力求解"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.暴力求解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-哈希表-1"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-夹逼法"><span class="toc-number">1.7.3.</span> <span class="toc-text">3.夹逼法</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">qxlx</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">i</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Array</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p>[TOC]</p>
<h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h2><blockquote>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>:</p>
<ol>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ol>
</blockquote>
<h3 id="1-空间最优，操作局部优化（双指针）"><a href="#1-空间最优，操作局部优化（双指针）" class="headerlink" title="-1.空间最优，操作局部优化（双指针）"></a>-1.空间最优，操作局部优化（双指针）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要思路  loop 2 次  第一次将所有非0元素移动到应该在的地方。</span></span><br><span class="line"><span class="comment">//第二次将后面的全部设置为0 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> modifyIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[modifyIndex++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;modifyIndex&lt;nums.length;modifyIndex++)&#123;</span><br><span class="line">            nums[modifyIndex] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)</p>
<h3 id="2-一次loop"><a href="#2-一次loop" class="headerlink" title="2.一次loop"></a>2.一次loop</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">* 思路:快排的思想找到一个中间点的数 比如 -21 -23 4 5 0 找到一个midNum数 作为标尺 来计算</span></span><br><span class="line"><span class="comment">  * 因此 在本题中找出所有0 用0作为一个标尺 0左边的都是非0 右边是0  </span></span><br><span class="line"><span class="comment">  * 通过一个loop就可以了。</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length ; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">             nums[i] = nums[j];</span><br><span class="line">             nums[j++] = temp;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n)</p>
<h3 id="3-滚雪球"><a href="#3-滚雪球" class="headerlink" title="3.滚雪球"></a>3.滚雪球</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 滚雪球</span></span><br><span class="line"><span class="comment">     *  一次loop 记录0的元素，如果不为0 与前面的元素进行交换  直到最后。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ballSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                ballSize++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ballSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                nums[i-ballSize] = nums[i];</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n)</p>
<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h2><blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>示例 1：</p>
<p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
</blockquote>
<h3 id="1-暴力破解"><a href="#1-暴力破解" class="headerlink" title="1.暴力破解"></a>1.暴力破解</h3><p>思路:我们可以将问题简单化，一个2个台阶可以分成是走2步和走1步结果的和。依次调用这个函数。进行细化求解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( n== <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> climbStairs(n-<span class="number">1</span>)+climbStairs(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(2^n)  由于时间过程 提交失败 </p>
<p>空间复杂度：O(n)</p>
<h3 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="-2.动态规划"></a>-2.动态规划</h3><p>不难发现，这个问题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建，我们可以使用动态规划来解决这一问题。</p>
<p>dp[i]=dp[i−1]+dp[i−2]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> [] num = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      num[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">          num[i] = num[i-<span class="number">1</span>]+num[i-<span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> num[n];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-container-with-most-water"><a href="#11-container-with-most-water" class="headerlink" title="11.container-with-most-water"></a>11.container-with-most-water</h2><blockquote>
<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-枚举"><a href="#1-枚举" class="headerlink" title="1.枚举"></a>1.枚举</h3><p>思路:枚举 类似冒泡一样 遍历每个元素与另一个元素的大小 <strong>下标值为长   数组的值为宽</strong></p>
<p>时间复杂度:O(n^2)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int maxArea(int[] height) &#123;</span><br><span class="line">        int maxArea &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; height.length-1 ; i++) &#123;</span><br><span class="line">            for (int j &#x3D; i+1; j &lt; height.length; j++) &#123;</span><br><span class="line">                int area &#x3D; (j-i)*Math.min(height[i],height[j]);&#x2F;&#x2F;长*宽</span><br><span class="line">                maxArea &#x3D; Math.max(maxArea,area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxArea;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-左右夹逼"><a href="#2-左右夹逼" class="headerlink" title="-2.左右夹逼"></a>-2.左右夹逼</h3><p>思路:通过依次loop i从最前面开始 向右移动 j从最后面向前移动 每次比较 如果较小，继续寻找更大的。</p>
<p>时间复杂度:O(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int maxArea(int[] height) &#123;</span><br><span class="line">        int maxArea &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0,j &#x3D; height.length-1; i &lt; j ; ) &#123;</span><br><span class="line">            &#x2F;&#x2F;计算出最小的高</span><br><span class="line">            int minHeight &#x3D; height[i] &lt;height[j] ? height[i++] : height[j--];</span><br><span class="line">            int area &#x3D; (j-i+1)*minHeight;</span><br><span class="line">            maxArea &#x3D; Math.max(area,maxArea);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxArea;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.<a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">移除元素</a></h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</span><br><span class="line">* 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</span><br><span class="line">* 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line">* 示例 1:</span><br><span class="line">* 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3,</span><br><span class="line">* 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line">* 你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-拷贝覆盖"><a href="#1-拷贝覆盖" class="headerlink" title="1.拷贝覆盖"></a>1.拷贝覆盖</h3><p>主要思路:定义一个变量，对不重复的值计数。for循环完成。</p>
<p>存在的问题 就是值可以计算出当前不相同值，数组的值是不符合要求的。</p>
<p><strong>这种思路在移除元素较多时更适合使用，最极端的情况是全部元素都需要移除，遍历一遍结束即可</strong></p>
<p><strong>时间复杂度:O(n) 空间复杂度O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeElement3</span><span class="params">(<span class="keyword">int</span> [] nums,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num!=val)&#123;</span><br><span class="line">                nums[count++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-交换移除"><a href="#2-交换移除" class="headerlink" title="2.交换移除"></a>2.交换移除</h3><p>主要思路:用一个变量去记录数组的长度，然后处理两种情况，一种是当前的值等于val 就将数组中最后的值赋值给当前相同的值，m 用来不断减少数组的长度。否则的话 是另一种情况 如果不相等 直接i++ 判断下一个就可以。</p>
<p><strong>这种思路在移除元素较少时更适合使用，最极端的情况是没有元素需要移除，遍历一遍结束即可</strong></p>
<p>时间复杂度：O(n)，空间复杂度：O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeElement4</span><span class="params">(<span class="keyword">int</span> [] nums,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ) &#123;<span class="comment">//注意for 这里不能i++ i是用来确认哪些数据不是要寻找的</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val)&#123;</span><br><span class="line">                nums[i] = nums[m-<span class="number">1</span>];</span><br><span class="line">                m--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-双指针"><a href="#3-双指针" class="headerlink" title="3.双指针"></a>3.双指针</h3><p>实现思路:一个快指针 一个慢指针。用快指针来判断是否相等 不相等赋值给慢指针，慢指针的作用是来定位前面如果有重复的直接跳过去。</p>
<p>时间复杂度:o(n)</p>
<p>空间复杂度:o(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeElement5</span><span class="params">(<span class="keyword">int</span> [] nums,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j]!=val)&#123;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                i++;<span class="comment">//加1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果相等 不做 等待下标i来进行覆盖</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-双指针-要删除的元素很少时"><a href="#4-双指针-要删除的元素很少时" class="headerlink" title="4.双指针-要删除的元素很少时"></a>4.双指针-要删除的元素很少时</h3><p>实现思路:通过快慢指针 在一种比较极端的情况下。nums[1,2,3,5,4] val = 4 在最后才可以找到需要删除的元素，虽然nums中的值没有改变，但是通过m– 停止了循环 i=4。</p>
<p>当我们遇到 nums[i] = valnums[i]=val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。</p>
<p>时间复杂度:O(n)</p>
<p>空间复杂度:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeElement6</span><span class="params">(<span class="keyword">int</span> [] nums,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;m)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val)&#123;<span class="comment">//相当的话 直接将快指针元素赋值给慢指针</span></span><br><span class="line">                nums[i] = nums[m-<span class="number">1</span>];</span><br><span class="line">                m--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;<span class="comment">//不相等 直接跳过</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h2><blockquote>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p>示例 1:</p>
<p>输入: [1,3,5,6], 5<br>输出: 2</p>
</blockquote>
<h3 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h3><p>实现思路: 使用二分查找就可以了。如果使用for循环的话，时间复杂度为O(n) 但是使用二分查找 时间复杂度就下降了很多，因此 注意边界的控制。</p>
<p>1.当target与查询的mid值相等 返回</p>
<p>2.当mid的值大于target max = mid-1;</p>
<p>3.当mid的值小于target min = mid+1</p>
<p>时间复杂度:o(logn)</p>
<p>注意边界的控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (min&lt;=max)&#123;</span><br><span class="line">            <span class="comment">//如果找到</span></span><br><span class="line">            mid = (min+max)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">                min = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                max = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
</blockquote>
<h3 id="1-暴力破解-1"><a href="#1-暴力破解-1" class="headerlink" title="1.暴力破解"></a>1.暴力破解</h3><p>thinking:通过两次loop 就可以找到，但是时间复杂度为O(n^2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target-nums[i] == nums[j])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> []&#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException(<span class="string">"no find two sum !"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-哈希表"><a href="#2-哈希表" class="headerlink" title="-2.哈希表"></a>-2.哈希表</h3><p>thiking：将数组中元素值作为key 存储到hashmap中 然后取寻找。遍历就可以了。</p>
<p>时间复杂度:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       Map&lt;Integer,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           hashMap.put(nums[i],i);<span class="comment">//将值作为key 可以保证数据不会出现重复</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length ; i++) &#123;</span><br><span class="line">           <span class="keyword">int</span> num = target - nums[i];</span><br><span class="line">           <span class="keyword">if</span> (hashMap.containsKey(num) &amp;&amp; hashMap.get(num)!=i)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> []&#123;i,hashMap.get(num)&#125;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException(<span class="string">"no find!"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><blockquote>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
</blockquote>
<h3 id="1-暴力求解"><a href="#1-暴力求解" class="headerlink" title="1.暴力求解"></a>1.暴力求解</h3><p>thinking:通过三层loop  这里如果使用ArrryList 是有序 可重复，不能避免元素重复问题。但是使用</p>
<p>LikedHashSet就可以<strong>避免元素重复问题</strong>。</p>
<p>时间复杂度:O(n^3)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">       <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;=<span class="number">2</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">       Set&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> k = j+<span class="number">1</span>;k&lt;nums.length;k++)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(nums[i]+nums[j]+nums[k] == <span class="number">0</span>)&#123;</span><br><span class="line">                       List&lt;Integer&gt; list = Arrays.asList(nums[i],nums[j],nums[k]);</span><br><span class="line">                       result.add(list);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-哈希表-1"><a href="#2-哈希表-1" class="headerlink" title="2.哈希表"></a>2.哈希表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * hash slow</span></span><br><span class="line"><span class="comment">    * 1406 ms	46 MB</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; hashSolution(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> target = -nums[i];</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;(nums.length - i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = target - nums[j];</span><br><span class="line">            Integer exist = hashMap.get(v);</span><br><span class="line">            <span class="keyword">if</span> (exist != <span class="keyword">null</span>) &#123;</span><br><span class="line">                List&lt;Integer&gt; list = Arrays.asList(nums[i], exist, nums[j]);</span><br><span class="line">                list.sort(Comparator.naturalOrder());</span><br><span class="line">                result.add(list);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hashMap.put(nums[j], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-夹逼法"><a href="#3-夹逼法" class="headerlink" title="3.夹逼法"></a>3.夹逼法</h3><p>thingking:左右夹逼，三数求和 a+b+c = 0  等价于 a+b=c   将数组进行排序，将c固定 a设置到c的下一个问题，也就是head  b设置到最后一个位置 tail位置。  </p>
<p>第一次遍历c固定 head 和tail 分别向中间移动，判断如果-sum &lt; target 说明值大 因为是负数。所以tail 左移动，否则就是head右移动。如此一轮后 如果找不到，接着c++ head 和tail接着判断。</p>
<p>就可以找到。时间复杂度相对于上面两种是比较低的。</p>
<p>时间复杂度:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> || nums.length &lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//元素去重</span></span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> head = i+<span class="number">1</span>;<span class="comment">//左端</span></span><br><span class="line">            <span class="keyword">int</span> tail = nums.length-<span class="number">1</span>;<span class="comment">//右端</span></span><br><span class="line">            <span class="keyword">while</span> (head&lt;tail)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = -(nums[head]+nums[tail]);<span class="comment">//取负值</span></span><br><span class="line">                <span class="keyword">if</span> (sum == nums[i])&#123;</span><br><span class="line">                    List&lt;Integer&gt; list = 			Arrays.asList(nums[i],nums[head],nums[tail]);</span><br><span class="line">                    result.add(list);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sum&lt;=nums[i])&#123;</span><br><span class="line">                    tail--;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    head++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">qxlx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/03/25/Array/">http://yoursite.com/2020/03/25/Array/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">i</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/03/25/LinkedList/"><i class="fa fa-chevron-left">  </i><span>LinkedList</span></a></div><div class="next-post pull-right"><a href="/2020/03/25/test/"><span>test</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By qxlx</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>