<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Tree"><meta name="keywords" content=""><meta name="author" content="qxlx"><meta name="copyright" content="qxlx"><title>Tree | qxlxi</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#树"><span class="toc-number">1.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#94-二叉树的中序遍历"><span class="toc-number">1.1.</span> <span class="toc-text">94.二叉树的中序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-递归法"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.递归法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-基于栈的遍历"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.基于栈的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#144-二叉树的前序遍历"><span class="toc-number">1.2.</span> <span class="toc-text">144.二叉树的前序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-递归法-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.递归法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-基于栈的遍历-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.基于栈的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#590-N叉数的后序遍历"><span class="toc-number">1.3.</span> <span class="toc-text">590.N叉数的后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#590-N叉树的后序遍历"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">590. N叉树的后序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-递归"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-栈迭代"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.栈迭代</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#589-N叉树的前序遍历"><span class="toc-number">1.4.</span> <span class="toc-text">589.N叉树的前序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#589-N叉树的前序遍历-1"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">589. N叉树的前序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-递归-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-栈迭代-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.栈迭代</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#429-N叉数的层序遍历"><span class="toc-number">1.5.</span> <span class="toc-text">429.N叉数的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#429-N叉树的层序遍历"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">429. N叉树的层序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-队列实现广度优先搜索"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.队列实现广度优先搜索</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">qxlx</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">qxlxi</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Tree</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-22</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>[TOC]</p>
<p><img src="e://pic/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20200329191409.png" alt=""></p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h2><blockquote>
<p>给定一个二叉树，返回它的中序 遍历。</p>
<p>示例:</p>
<p>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3</p>
<p>输出: [1,3,2]</p>
</blockquote>
<h3 id="1-递归法"><a href="#1-递归法" class="headerlink" title="1.递归法"></a>1.递归法</h3><p>我们知道二叉树的遍历有前序遍历 中序遍历 后序遍历。</p>
<p>前序遍历 :根左右</p>
<p>中序遍历:左根右</p>
<p>后序遍历:左右根</p>
<p>时间复杂度:O(n)。递归函数 T(n) = 2*T(n/2)+1 </p>
<p>空间辅助度:最坏情况下需要空间O(n),平均情况为O(log N)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       helper(root,result);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="comment">//左</span></span><br><span class="line">           <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               helper(root.left,result);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//中</span></span><br><span class="line">           result.add(root.val);</span><br><span class="line">           <span class="comment">//右</span></span><br><span class="line">           <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               helper(root.right,result);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-基于栈的遍历"><a href="#2-基于栈的遍历" class="headerlink" title="2.基于栈的遍历"></a>2.基于栈的遍历</h3><p>用一个栈接收访问的路径 因为栈是先进后出 所以最后访问的元素就是最先遍历的元素。先查找左节点 左节点完毕后 输出，查找右节点。</p>
<p>时间复杂度:O(n)</p>
<p>空间复杂度:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">       <span class="comment">//获取根节点 </span></span><br><span class="line">       TreeNode curr = root;</span><br><span class="line">       <span class="comment">//如果当前节点不为null or 栈不为null 说明还有节点没有遍历完</span></span><br><span class="line">       <span class="keyword">while</span>(curr != <span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">           <span class="comment">//先将左节点push 进</span></span><br><span class="line">           <span class="keyword">if</span>(curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.push(curr);</span><br><span class="line">               curr = curr.left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//后push的 先输出</span></span><br><span class="line">           curr = stack.pop();</span><br><span class="line">           result.add(curr.val);</span><br><span class="line">           <span class="comment">//查看当前节点的右节点 </span></span><br><span class="line">           curr = curr.right;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h2><blockquote>
<p>给定一个二叉树，返回它的 前序 遍历。</p>
<p> 示例:</p>
<p>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3 </p>
<p>输出: [1,2,3]</p>
</blockquote>
<h3 id="1-递归法-1"><a href="#1-递归法-1" class="headerlink" title="1.递归法"></a>1.递归法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        helper(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//根</span></span><br><span class="line">            result.add(root.val);</span><br><span class="line">            <span class="comment">//左</span></span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                helper(root.left,result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右</span></span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                helper(root.right,result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-基于栈的遍历-1"><a href="#2-基于栈的遍历-1" class="headerlink" title="2.基于栈的遍历"></a>2.基于栈的遍历</h3><p>其实我们使用递归去输出二叉树的遍历，计算机也是利用栈进行操作，我们可以模拟栈进行操作、</p>
<p>栈是先进后出的线性结构。因此 前序遍历是根左右  应该先push rootNode 输出。剩下就是左右节点的遍历，应该先push右节点，然后在push左节点，这样在pop的时候 顺序就是左右。</p>
<p>时间复杂度:O(n) 相当于树进行了一次loop操作</p>
<p>空间复杂度:O(n) 用栈做临时空间存储。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先将头结点条件进去</span></span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="comment">//添加右节点 因为栈是先进后出 而前序遍历是根左右 所以右节点陷进去最后出来</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//添加左节点 </span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="590-N叉数的后序遍历"><a href="#590-N叉数的后序遍历" class="headerlink" title="590.N叉数的后序遍历"></a>590.N叉数的后序遍历</h2><blockquote>
<h4 id="590-N叉树的后序遍历"><a href="#590-N叉树的后序遍历" class="headerlink" title="590. N叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">590. N叉树的后序遍历</a></h4><p>难度简单58</p>
<p>给定一个 N 叉树，返回其节点值的<em>后序遍历</em>。</p>
<p>例如，给定一个 <code>3叉树</code> :</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" alt="img"></p>
<p>返回其后序遍历: <code>[5,6,3,2,4,1]</code>.</p>
</blockquote>
<h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><p>时间复杂度:O(n)</p>
<p>空间复杂度:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="comment">//1.一个LikedList链表存储数值</span></span><br><span class="line">    <span class="comment">//2.递归调用</span></span><br><span class="line">    <span class="comment">// a.如果根节点为null 返回</span></span><br><span class="line">    <span class="comment">// b.依次遍历根节点的孩子节点 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        recur(root);</span><br><span class="line">        <span class="keyword">return</span> linkedList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node node : root.children)&#123;</span><br><span class="line">            recur(node);</span><br><span class="line">        &#125;</span><br><span class="line">        linkedList.add(root.val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-栈迭代"><a href="#2-栈迭代" class="headerlink" title="2.栈迭代"></a>2.栈迭代</h3><p>时间复杂度:O(n)</p>
<p>空间复杂度:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.N叉树的后序遍历 左右根 </span></span><br><span class="line">  <span class="comment">// 2.用一个链表存储数据 每次添加首节点 依次往后移动</span></span><br><span class="line">  <span class="comment">// 3.将root节点push到栈中 遍历左右子节点。如果不为null 继续</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">      LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">      Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">      stack.push(root);</span><br><span class="line">      <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">          root = stack.pop();</span><br><span class="line">          linkedList.offerFirst(root.val);<span class="comment">//先进排在最后</span></span><br><span class="line">          <span class="keyword">for</span>(Node node : root.children)&#123;</span><br><span class="line">              stack.push(node);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> linkedList;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="589-N叉树的前序遍历"><a href="#589-N叉树的前序遍历" class="headerlink" title="589.N叉树的前序遍历"></a>589.N叉树的前序遍历</h2><blockquote>
<h4 id="589-N叉树的前序遍历-1"><a href="#589-N叉树的前序遍历-1" class="headerlink" title="589. N叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">589. N叉树的前序遍历</a></h4><p>难度简单71</p>
<p>给定一个 N 叉树，返回其节点值的<em>前序遍历</em>。</p>
<p>例如，给定一个 <code>3叉树</code> :</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" alt="img"></p>
<p>返回其前序遍历: <code>[1,3,5,6,2,4]</code>。</p>
</blockquote>
<h3 id="1-递归-1"><a href="#1-递归-1" class="headerlink" title="1.递归"></a>1.递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历  根左右  递归调用即可。</span></span><br><span class="line">    <span class="comment">//先将节点的值存储到linkedList中</span></span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; linkedList = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList() : recur(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LinkedList&lt;Integer&gt; <span class="title">recur</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        linkedList.add(root.val);</span><br><span class="line">        <span class="keyword">for</span>(Node node : root.children)&#123;</span><br><span class="line">            recur(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> linkedList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-栈迭代-1"><a href="#2-栈迭代-1" class="headerlink" title="2.栈迭代"></a>2.栈迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line">   <span class="comment">//前序遍历 根-左-右</span></span><br><span class="line">   <span class="comment">//1.将根节点存储到stack中</span></span><br><span class="line">   <span class="comment">//2.逆序将子节点添加到栈中 比如 push的顺序为 2 3 4  则输出的顺序为 4 3 2 </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">       stack.push(root);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">           root = stack.pop();</span><br><span class="line">           list.add(root.val);</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=root.children.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">               stack.push(root.children.get(i));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="429-N叉数的层序遍历"><a href="#429-N叉数的层序遍历" class="headerlink" title="429.N叉数的层序遍历"></a>429.N叉数的层序遍历</h2><blockquote>
<h4 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429. N叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">429. N叉树的层序遍历</a></h4><p>难度中等76</p>
<p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。 (即从左到右，逐层遍历)。</p>
<p>例如，给定一个 <code>3叉树</code> :</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" alt="img"></p>
<p>返回其层序遍历:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">     [3,2,4],</span><br><span class="line">     [5,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-队列实现广度优先搜索"><a href="#1-队列实现广度优先搜索" class="headerlink" title="1.队列实现广度优先搜索"></a>1.队列实现广度优先搜索</h3><p>time:O(n)</p>
<p>space:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.用队列实现广度优先搜索</span></span><br><span class="line">   <span class="comment">//2.一个list 一个queue  list存储节点的值  queue存储每一层遍历的节点。</span></span><br><span class="line">   <span class="comment">//3.当queue != null 的时候，遍历当前层。</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList();<span class="comment">//存储每一层的结点值</span></span><br><span class="line">       queue.add(root);</span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">           List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">int</span> size = queue.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">               Node node = queue.poll();</span><br><span class="line">               level.add(node.val);</span><br><span class="line">               queue.addAll(node.children);</span><br><span class="line">           &#125;</span><br><span class="line">           list.add(level);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">qxlx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/04/22/Tree/">http://yoursite.com/2020/04/22/Tree/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">qxlxi</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/04/22/%E5%89%91%E6%8C%87offer/"><i class="fa fa-chevron-left">  </i><span>剑指offer</span></a></div><div class="next-post pull-right"><a href="/2020/04/22/Stack/"><span>Stack</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By qxlx</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>