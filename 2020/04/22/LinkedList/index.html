<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="LinkedList"><meta name="keywords" content=""><meta name="author" content="qxlx"><meta name="copyright" content="qxlx"><title>LinkedList | ��Ϊ�Ȱ� ��������Ϊ��������Ϊ��</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#LinkedList"><span class="toc-number">1.</span> <span class="toc-text">LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#53-最大子序和？？"><span class="toc-number">1.1.</span> <span class="toc-text">53. 最大子序和？？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#206-反转链表"><span class="toc-number">1.2.</span> <span class="toc-text">206.反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-环形链表"><span class="toc-number">1.3.</span> <span class="toc-text">141.环形链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-快慢指针"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.快慢指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-哈希表"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.哈希表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-合并K个排序链表"><span class="toc-number">1.4.</span> <span class="toc-text">23.合并K个排序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-不使用递归"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.不使用递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-两两交换链表中的节点"><span class="toc-number">1.5.</span> <span class="toc-text">24.两两交换链表中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-递归"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.递归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#递归简洁版"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">-递归简洁版</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-迭代法"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.迭代法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-K-个一组翻转链表"><span class="toc-number">1.6.</span> <span class="toc-text">25.K 个一组翻转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-合并两个有序链表"><span class="toc-number">1.7.</span> <span class="toc-text">21. 合并两个有序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-迭代"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-递归"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.递归</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">qxlx</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">��Ϊ�Ȱ� ��������Ϊ��������Ϊ��</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">LinkedList</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-22</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>高频题</p>
<p><img src="e://pic/7430894_1569830509086_8E72661D2242C40ECD146E2DB6D88051.png" alt=""></p>
<h2 id="53-最大子序和？？"><a href="#53-最大子序和？？" class="headerlink" title="53. 最大子序和？？"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a>？？</h2><blockquote>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">crossSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftSubsum = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> currSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &gt; left - <span class="number">1</span>; --i) &#123;</span><br><span class="line">            currSum += nums[i];</span><br><span class="line">            leftSubsum = Math.max(leftSubsum, currSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rightSubsum = Integer.MIN_VALUE;</span><br><span class="line">        currSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p + <span class="number">1</span>; i &lt; right + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            currSum += nums[i];</span><br><span class="line">            rightSubsum = Math.max(rightSubsum, currSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftSubsum + rightSubsum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftSum = helper(nums, left, p);</span><br><span class="line">        <span class="keyword">int</span> rightSum = helper(nums, p + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">int</span> crossSum = crossSum(nums, left, right, p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(leftSum, rightSum), crossSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h2><blockquote>
<p>反转一个单链表。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现思路 </span></span><br><span class="line"><span class="comment">//在遍历列表时，将当前节点的next指针改为指向前一个元素，由于节点没有引用其上一个节点，因此必须实现存储前一个元素，在更改引用之前，还需要另一个指针来存储一个节点，不要忘记在最后返回新的头引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;<span class="comment">//设置一个null结点</span></span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode next = cur.next; <span class="comment">//记录ListNode节点</span></span><br><span class="line">        cur.next = prev;<span class="comment">//将cur.next 设置为null</span></span><br><span class="line">        prev = cur; <span class="comment">//当前节点赋值成prev</span></span><br><span class="line">        cur = next; <span class="comment">//当前节点设置成cur</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)O(n)，假设 n是列表的长度，时间复杂度是 O(n)O(n)。</li>
<li>空间复杂度：O(1)O(1)。</li>
</ul>
<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h2><blockquote>
<p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>示例 1：</p>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
</blockquote>
<p><img src="e:///pic/lc-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88.png" alt=""></p>
<h3 id="1-快慢指针"><a href="#1-快慢指针" class="headerlink" title="1.快慢指针"></a>1.快慢指针</h3><p>可以类比成两个运动员 在同一个环形运动场跑步，一个跑的快的 和 一个跑的慢的 在一定的时间内 快的一定会和慢的相遇，这个时候 就说明 有环存在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查是否链表中有环</span></span><br><span class="line">    <span class="comment">//思路:定义一个快指针 和 一个慢指针 慢指针一次走一步 快指针一次走两步</span></span><br><span class="line">    <span class="comment">//如果有环 一定会相遇。多次循环</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fastNode = head.next;</span><br><span class="line">        ListNode slowNode = head;</span><br><span class="line">        <span class="keyword">while</span> (fastNode!=<span class="keyword">null</span> &amp;&amp; fastNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fastNode = fastNode.next.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">            <span class="keyword">if</span> (slowNode == fastNode)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>分析:</p>
<p>时间复杂度:o(n)</p>
<p>1.第一种情况  链表不存在环 快慢指针分别到达尾部，其时间取决于列表的长度。O(n)</p>
<p>2.第二种情况  链表中存在环  在最糟糕的情形下，时间复杂度为 O(N+K)O(N+K)，也就是 O(n)</p>
<p>空间复杂度 o(1)</p>
<p>只是用了快慢指针两个结点。</p>
<h3 id="2-哈希表"><a href="#2-哈希表" class="headerlink" title="2.哈希表"></a>2.哈希表</h3><p>思路: 通过创建哈希表，遍历链表 将每次遍历的都存储到哈希表中 如果哈希表中有当前哈希值 说明 遍历到了环形处，说明是环形链表 否则的话 遍历完  说明不是环形链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set nodeSet = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeSet.contains(head))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nodeSet.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(n) 对于含有n个元素的链表 </p>
<p>空间复杂度:   o(n) 最坏情况下 全部添加 所有取决于哈希表中的元素数目</p>
<h2 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23.合并K个排序链表"></a>23.合并K个排序链表</h2><blockquote>
<p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p>示例:</p>
<p>输入:<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
</blockquote>
<h3 id="1-不使用递归"><a href="#1-不使用递归" class="headerlink" title="1.不使用递归"></a>1.不使用递归</h3><p>基本思路：我们可以使用分治思想 来解决这个问题。当一个链表集合中需要合并并排序。我们可以假设只有2个 每次合并两个。两个合并一个。这样就可以获取到最终的结果。</p>
<p>第一次将list[0]与list[len-1]合并 2次list[1]与list[len-2] 经过 for循环一次后。可以等到一半的list链表结合。在依次len = len/2; 依次合并 就可以获取到下标为0的为头结点的这个链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并两个有序的链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = lists.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">                lists[i] = merageKList(lists[i],lists[len-<span class="number">1</span>-i]);</span><br><span class="line">            &#125;</span><br><span class="line">            len = (len+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并两个有序的链表 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merageKList</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode listNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode head = listNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.data &lt; l2.data) &#123;</span><br><span class="line">                head.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head.next = l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listNode.next; <span class="comment">//note 注意返回的不是head 返回head 会带有 -1这个结点的值 只需要后边的值 牛掰思想</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：整体时间复杂度为O(N*log(k)), k为链表个数，N为链表平均长度。</p>
<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 示例: </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F; Related Topics 链表</span><br></pre></td></tr></table></figure>

<h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><p>thinking: 使用递归的方法  每一次递归都交换一对节点，用firstNode.next 记录上一次节点交换后的首节点。secondNode节点作为首节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if the list has no node or has only one node left</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Nodes to be swapped</span></span><br><span class="line">        ListNode firstNode = head;</span><br><span class="line">        ListNode secondNode = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//swapping</span></span><br><span class="line">        firstNode.next = swapPairs(secondNode.next);</span><br><span class="line">        secondNode.next = firstNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Now the head is the second node</span></span><br><span class="line">        <span class="keyword">return</span> secondNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)    O(N)，其中 N 指的是链表的节点数量。</li>
<li>空间复杂度：O(N)    O(N)，递归过程使用的堆栈空间。</li>
</ul>
<h4 id="递归简洁版"><a href="#递归简洁版" class="headerlink" title="-递归简洁版"></a>-递归简洁版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ((head == <span class="keyword">null</span>)||(head.next == <span class="keyword">null</span>))</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       ListNode n = head.next;</span><br><span class="line">       head.next = swapPairs(head.next.next);</span><br><span class="line">       n.next = head;</span><br><span class="line">       <span class="keyword">return</span> n;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-迭代法"><a href="#2-迭代法" class="headerlink" title="2.迭代法"></a>2.迭代法</h3><p>thinking：定义一个前驱节点，记录每次交换后的节点变化</p>
<p>head节点和pre节点每次交换完成后重置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">     *  迭代法</span></span><br><span class="line"><span class="comment">     *  1.定义一个前驱节点，用以记录每次交换后的元素的前置节点</span></span><br><span class="line"><span class="comment">     *  2.交换</span></span><br><span class="line"><span class="comment">     *  3.head 节点 和pre节点重置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((head!=<span class="keyword">null</span>) &amp;&amp; (head.next !=<span class="keyword">null</span>))&#123;</span><br><span class="line"></span><br><span class="line">            ListNode firstNode = head;</span><br><span class="line">            ListNode secondNode = head.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//swap</span></span><br><span class="line">            pre.next = secondNode;<span class="comment">//-1 -&gt; 2</span></span><br><span class="line">            firstNode.next = secondNode.next;<span class="comment">// 1 -&gt; 3</span></span><br><span class="line">            secondNode.next = firstNode;</span><br><span class="line"></span><br><span class="line">            pre = firstNode;</span><br><span class="line">            head = firstNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)，其中 N 指的是链表的节点数量。</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25.K 个一组翻转链表"></a>25.K 个一组翻转链表</h2><blockquote>
<p>难度困难416</p>
<p>给你一个链表，每 *k *个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>*k *是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 *k *的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p><strong>示例：</strong></p>
<p>给你这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>当 *k *= 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>当 *k *= 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p><strong>说明：</strong></p>
<ul>
<li>你的算法只能使用常数的额外空间。</li>
<li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 迭代法</span></span><br><span class="line"><span class="comment">     * 1.链表分区已翻转 + 待翻转 + 未翻转部分</span></span><br><span class="line"><span class="comment">     * 2.翻转前确定翻转的范围 通过k来决定</span></span><br><span class="line"><span class="comment">     * 3.记录链表前驱和后继 方便翻转完成后，把已翻转和未翻转连接起来。</span></span><br><span class="line"><span class="comment">     * 4.初始化两个边路pre  end  pre &gt;代表待翻转链表的前驱，end代表待翻转的末尾。</span></span><br><span class="line"><span class="comment">     * 5.经过k次 end到达链表末尾。  记录待翻转链表的后继 next = end.next</span></span><br><span class="line"><span class="comment">     * 6.翻转链表，将三部分连接起来，然后重置pre 和 end 指针 进入下一个循环</span></span><br><span class="line"><span class="comment">     * 7.特殊情况 翻转部分长度不足k时，在定位end 完成后，end = null 已经到达末尾。</span></span><br><span class="line"><span class="comment">     * 8.时间复杂度为 O(n*K) 最好的情况为 O(n) 最差的情况未 O(n^2)</span></span><br><span class="line"><span class="comment">     * 9.空间复杂度为 O(1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode dumy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dumy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode pre = dumy;</span><br><span class="line">        ListNode end = dumy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (end.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//确定待翻转的范围</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                end = end.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (end == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ListNode start = pre.next;<span class="comment">//待翻转链表的开始位置</span></span><br><span class="line">            ListNode next = end.next;<span class="comment">//下一个待翻转链表的起始位置</span></span><br><span class="line"></span><br><span class="line">            end.next = <span class="keyword">null</span>;<span class="comment">//和后继待翻转链表断开</span></span><br><span class="line"></span><br><span class="line">            pre.next = reverse(start);</span><br><span class="line">            start.next = next;</span><br><span class="line">            pre = start;</span><br><span class="line"></span><br><span class="line">            end = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dumy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="comment">//假设 1 -&gt; 2 -&gt; 3</span></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = curr.next; <span class="comment">// next = 2   // next = 3</span></span><br><span class="line">            curr.next = pre;<span class="comment">// 1.next = null        // 3.next = 1</span></span><br><span class="line">            pre = curr;<span class="comment">// pre = 1;                 //  1 = 3</span></span><br><span class="line">            curr = next; <span class="comment">// curr = 2              // 3  = null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre; <span class="comment">//</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h2><blockquote>
<p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="1-迭代"><a href="#1-迭代" class="headerlink" title="1.迭代"></a>1.迭代</h3><p>th:主要是通过定义一个head节点 遍历两个链表就可以，最后一定会有一个链表没有遍历完 使用三目运算符进行算</p>
<p><strong>需要注意的点</strong>  因为head节点一直next next下去 所以应该定义一个root节点 作为根节点 head节点 一直next下去。返回的是root节点</p>
<p>time:O(m+n)</p>
<p>space:O(1) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    *思路 主要是通过定义一个head节点 遍历两个链表就可以，最后一定会有一个链表没有遍历完 使用三目运算符进行算</span></span><br><span class="line"><span class="comment">    notice 因为head节点一直next next下去 所以应该定义一个root节点 作为根节点 head节点 一直next下去。返回的是root节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span> || l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode root = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode head = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span> &amp;&amp; l2!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                head.next = l1;</span><br><span class="line">                l1 = l1.next; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                head.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head.next = (l1 == <span class="keyword">null</span> ? l2 : l1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-递归"><a href="#2-递归" class="headerlink" title="2.递归"></a>2.递归</h3><p>th：其实如果一个方法可以迭代就可以递归解决，但是递归代码虽然简洁 理解上比较难一些，递归代码无非就是 三点需要注意：1 终止条件 2. 业务逻辑 3.解决下一个子问题 也就是 调用自身。</p>
<p>time:O(m+n)</p>
<p>space:调用 mergeTwoLists 退出时 l1 和 l2 中每个元素都一定已经被遍历过了，所以 n + mn+m 个栈帧会消耗 O(n + m)O(n+m) 的空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(l1 == <span class="keyword">null</span> )&#123;</span><br><span class="line">           <span class="keyword">return</span> l2;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l2 ==  <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">           l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">           <span class="keyword">return</span> l2;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">qxlx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="/qxlx.github.io/2020/04/22/LinkedList/">qxlx.github.io/2020/04/22/LinkedList/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="qxlx.github.io">��Ϊ�Ȱ� ��������Ϊ��������Ϊ��</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/04/22/Queue/"><i class="fa fa-chevron-left">  </i><span>Queue</span></a></div><div class="next-post pull-right"><a href="/2020/04/22/Hash/"><span>Hash</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By qxlx</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>