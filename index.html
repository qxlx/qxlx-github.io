<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="qxlx"><meta name="copyright" content="qxlx"><title>i | i</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">qxlx</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">9</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">i</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">i</div><div id="site-sub-title">i</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/22/%E5%89%91%E6%8C%87offer/">剑指offer</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-22</time><div class="content"><h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><h2 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3.数组中重复的数字"></a>3.数组中重复的数字</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h3 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1.HashSet"></a>1.HashSet</h3><p>使用hashSet去重  如果添加不成功说明出现了重复的元素 返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums.length &lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> repeat = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(num)) &#123;</span><br><span class="line">                repeat = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> repeat;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n)</p>
<h3 id="2-利用下标"><a href="#2-利用下标" class="headerlink" title="2.利用下标"></a>2.利用下标</h3><p>将数组中的元素当成下标存储到数组中去，如果没有重复的就说明无重复数 否则有重复数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] != i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = nums[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4.二维数组中的查找"></a>4.二维数组中的查找</h2><blockquote>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
</blockquote>
<h3 id="1-暴力破解法"><a href="#1-暴力破解法" class="headerlink" title="1.暴力破解法"></a>1.暴力破解法</h3><p>thinking:两层loop 查找</p>
<p>时间复杂度:O(m<em>n)  *</em>二维数组中的每个元素都被遍历，因此时间复杂度为二维数组的大小。**</p>
<p>空间复杂度:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">    *1.暴力法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-线性查找"><a href="#2-线性查找" class="headerlink" title="2.线性查找"></a>2.线性查找</h3><p>thinking：通过分析，可以知道 如果使用暴力破解的话 会出现重复的元素查找，因此，在一定程度上，不可缺。如果一开始从右上角开始查找 如果target小于当前数 说明不在这一列，所以，排除掉一列，如果反复，如果当前数大于target说明在这一列上，rows++。</p>
<p>时间复杂度:O(m+n)  访问到的下标的行最多增加 <code>n</code> 次，列最多减少 <code>m</code> 次，因此循环体最多执行 <code>n + m</code> 次。</p>
<p>空间复杂度:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length-<span class="number">1</span>,cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>,c = cols-<span class="number">1</span>;<span class="comment">//右上角开始</span></span><br><span class="line">        <span class="keyword">while</span>(r&lt;=rows &amp;&amp; c &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = matrix[r][c];</span><br><span class="line">            <span class="keyword">if</span>(target == num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; num)&#123;</span><br><span class="line">                c--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5.替换空格"></a>5.替换空格</h2><blockquote>
<h4 id="面试题05-替换空格"><a href="#面试题05-替换空格" class="headerlink" title="面试题05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">面试题05. 替换空格</a></h4><p>难度简单8</p>
<p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>th:直接迭代就可以了 需要注意的是方法名的调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(Character ch : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">' '</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">"%20"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6.从尾到头打印链表"></a>6.从尾到头打印链表</h2><blockquote>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-使用栈"><a href="#1-使用栈" class="headerlink" title="1.使用栈"></a>1.使用栈</h3><p>th:逆序打印 我们可以将链表loop一遍，push到栈中。然后pop出 因为栈是先进后出 所有最后顺序就是逆序的顺序。 这里建议push最好是val push node的话 占用的内存空间比较大。</p>
<p>time: O(n) 需要遍历一遍链表</p>
<p>space:O(n) 需要大小为size的数组存储数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;ListNode&gt;stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> [] array = <span class="keyword">new</span> <span class="keyword">int</span> [stack.size()];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            array[i++] = stack.pop().val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-递归法"><a href="#2-递归法" class="headerlink" title="2.递归法"></a>2.递归法</h3><p>th: 递推阶段:每次传入head.next 以head.next ==null 为终止条件，此时返回。</p>
<p>回溯节点:层层回溯时，将以当前节点值加入列表。</p>
<p>最后转换成int数组即可。</p>
<p>time:O(n) 遍历链表n次</p>
<p>space:O(n) 系统递归需要使用O(n)的栈空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ListNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">      2.递归</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">      <span class="comment">//递归</span></span><br><span class="line">      reverse(head);</span><br><span class="line">      <span class="keyword">int</span> [] array = <span class="keyword">new</span> <span class="keyword">int</span> [list.size()];</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">          array[i] = list.get(i).val;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(ListNode curr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//2.递归子问题</span></span><br><span class="line">        reverse(curr.next);</span><br><span class="line">        <span class="comment">// 3.业务逻辑</span></span><br><span class="line">        list.add(curr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-头插法"><a href="#3-头插法" class="headerlink" title="3.头插法"></a>3.头插法</h3><p>头插法顾名思义是将节点插入到头部，在遍历原始链表时，将当前节点插入新链表的头部，使其称为第一个节点，</p>
<p>链表的操作需要维护后继关系，例如在某个节点node1之后插入一个节点node2,我们可以通过修改后继关系来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node3 = node1.next;</span><br><span class="line">node2.next = node3;</span><br><span class="line">node1.next = node2;</span><br></pre></td></tr></table></figure>

<p>​    为了能将一个节点插入头部，我们引入了一个叫<strong>头结点的辅助节点</strong>，该节点不存储值，只是为了方便进行插入操作。不要将头结点与第一个节点混起来，第一个节点是链表中第一个真正存储值的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头插法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">       ListNode node = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//1 while   -1 	--&gt;1 </span></span><br><span class="line">       <span class="comment">//2 while   -1 	--&gt;2   --&gt;1</span></span><br><span class="line">       <span class="comment">//3 while   -1 	--&gt;3   --&gt;2  --&gt;1</span></span><br><span class="line">       <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">           ListNode memo = head.next;  <span class="comment">//存储后继节点</span></span><br><span class="line">           head.next = node.next;  <span class="comment">//</span></span><br><span class="line">           node.next = head;  <span class="comment">//和头结点连接上</span></span><br><span class="line">           head = memo;  <span class="comment">//head 继续遍历下去</span></span><br><span class="line">           size++; </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span> [size];</span><br><span class="line">       head = node.next;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">           arr[i++] = head.val;</span><br><span class="line">           head = head.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="7.重建二叉树"></a>7.重建二叉树</h2><blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如，给出</p>
<p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p>
<pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7</p>
</blockquote>
<p>th:前序遍历第一个数就是root节点，而我们用map记录中序顺序，用根节点区分左右节点 递归调用。</p>
<p>time : O(n)</p>
<p>space : O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Map&lt;Integer,Integer&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">         result.put(inorder[i],i);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> recur(preorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">recur</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> preL,<span class="keyword">int</span> preR,<span class="keyword">int</span> inL)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(preL &gt; preR)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     TreeNode root = <span class="keyword">new</span> TreeNode(pre[preL]);</span><br><span class="line">     <span class="keyword">int</span> rootIndex = result.get(root.val);</span><br><span class="line">     <span class="keyword">int</span> size = rootIndex - inL;</span><br><span class="line">     root.left = recur(pre,preL+<span class="number">1</span>,preL+size,inL);</span><br><span class="line">     root.right = recur(pre,preL+<span class="number">1</span>+size,preR,inL+size+<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-用两个栈实现队列"><a href="#8-用两个栈实现队列" class="headerlink" title="8.用两个栈实现队列"></a>8.用两个栈实现队列</h2><blockquote>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<p>示例 1：</p>
<p>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]</p>
</blockquote>
<p>th：用两个栈，一个栈push数据 另一个栈pop数据</p>
<p>输入数据 1 2 3 push进inStack 为  3 2 1 在pop到outStack栈中 为1 2 3 和输入数据顺序一样、</p>
<p>time：O(1)</p>
<p>space:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 用两个栈，一个栈push数据 另一个栈pop数据</span></span><br><span class="line"><span class="comment">   输入数据 1 2 3 push进inStack 为  3 2 1 在pop到outStack栈中 为1 2 3 和输入数据顺序一样、</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   Stack&lt;Integer&gt; in;</span><br><span class="line">   Stack&lt;Integer&gt; out;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       in = <span class="keyword">new</span> Stack();</span><br><span class="line">       out = <span class="keyword">new</span> Stack();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">       in.push(value);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(out.empty())&#123;</span><br><span class="line">           <span class="keyword">while</span>(!in.empty())&#123;</span><br><span class="line">               out.push(in.pop());;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(out.empty())&#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> out.pop();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-斐波那契数列"><a href="#9-斐波那契数列" class="headerlink" title="9.斐波那契数列"></a>9.斐波那契数列</h2><blockquote>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<p>输入：n = 2<br>输出：1<br>示例 2：</p>
<p>输入：n = 5<br>输出：5</p>
</blockquote>
<h3 id="1-使用递归"><a href="#1-使用递归" class="headerlink" title="1.使用递归"></a>1.使用递归</h3><p>递归的使用就是将一个大问题分解成多个子问题进行递归解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>问题 递归调用的过程中会出现重复计算的子问题。当递归调用栈的深度超过系统栈 就会出异常。</p>
<h3 id="2记忆化递归法"><a href="#2记忆化递归法" class="headerlink" title="2记忆化递归法"></a>2记忆化递归法</h3><p>动态规划的思想也是将大问题化解成多个子问题，但是动态规划会将重复计算的子问题的解存储起来。这样避免了重复计算带来的性能开销。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> [] fib = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">        fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            fib[i] = fib[i-<span class="number">1</span>]+fib[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3.动态规划"></a>3.动态规划</h3><p>分析一下 空间复杂度是O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> fib = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fib = pre2 + pre1;</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = fib;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间复杂度由O(n)降低到O(1)</p>
<h3 id="4-循环求余法"><a href="#4-循环求余法" class="headerlink" title="4.循环求余法"></a>4.循环求余法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(N) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。<br>空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。</p>
<h2 id="10-青蛙跳台阶问题"><a href="#10-青蛙跳台阶问题" class="headerlink" title="10.青蛙跳台阶问题"></a>10.青蛙跳台阶问题</h2><blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<p>输入：n = 2<br>输出：2<br>示例 2：</p>
<p>输入：n = 7<br>输出：21</p>
</blockquote>
<p>time : O(n)</p>
<p>space:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11. 旋转数组的最小数字"></a>11. 旋转数组的最小数字</h2><blockquote>
<p>难度简单35</p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1。  </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
</blockquote>
<p>th:这道题主要的关键点在于找到递增后减小的位置，使用二分可以解决。</p>
<p>有三种情况</p>
<p>1.当nums[mid]&gt;nums[right] 说明 一定在右边  ps : 1 3 4 5 0 2 mid&gt;right   left = mid+1;</p>
<p>2.当nums[mid] = nums[right]  说明出现了重复的元素  这个时候要缩小范围  right = right-1</p>
<p>3.当nums[mid] &lt; nums[right]  说明 一定在左边  right = mid;</p>
<p>time:O(logN)  当出现 1 1 1 1 会退化到O(n)</p>
<p>space:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> length = numbers.length;</span><br><span class="line">       <span class="keyword">if</span>(length == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>,right = length-<span class="number">1</span>;</span><br><span class="line">     </span><br><span class="line">       <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">             <span class="keyword">int</span> mid = (left+right) &gt;&gt;&gt;<span class="number">1</span>;<span class="comment">//获取中点位置</span></span><br><span class="line">           <span class="comment">// 3 4 5 1 2 </span></span><br><span class="line">           <span class="keyword">if</span>(numbers[mid]&gt;numbers[right])&#123;</span><br><span class="line">               <span class="comment">//右边</span></span><br><span class="line">               left = mid+<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] == numbers[right])&#123;</span><br><span class="line">               <span class="comment">//缩小范围</span></span><br><span class="line">               right = right-<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//numbers[mid] &lt; number[right]</span></span><br><span class="line">               right = mid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> numbers[left];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15.二进制中1的个数"></a>15.二进制中1的个数</h2><blockquote>
<h4 id="难度简单14收藏分享切换为英文关注反馈"><a href="#难度简单14收藏分享切换为英文关注反馈" class="headerlink" title="难度简单14收藏分享切换为英文关注反馈"></a>难度简单14收藏分享切换为英文关注反馈</h4><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-逐位判断"><a href="#1-逐位判断" class="headerlink" title="1.逐位判断"></a>1.逐位判断</h3><p>th：使用位运算符将数字每次右移一次 &amp; 1如果为1 就result++ </p>
<p>time:O(n)</p>
<p>space:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            result+= n &amp; <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-巧用n-amp-n-1"><a href="#2-巧用n-amp-n-1" class="headerlink" title="2.巧用n &amp;=(n-1)"></a>2.巧用n &amp;=(n-1)</h3><p>th:假设 n = 3      n= 0101   n-1 = 0100   n&amp;=(n-1)   n = 0100  消去一个1 result++  再次循环  </p>
<p>n -1 = 0000     n&amp;=(n-1)  n=0 退出循环  result = 2 </p>
<p>time:O(n)</p>
<p>space:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.巧用 n&amp;=(n-1)</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            result++;</span><br><span class="line">            n &amp;= (n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16.数值的整数次方"></a>16.数值的整数次方</h2><blockquote>
<p><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">面试题</a></p>
<p>难度中等14</p>
<p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1.暴力"></a>1.暴力</h3><p>如果n&lt;0 x= 1/x n = -n 遍历求解 result = result * x;</p>
<p>time：O(n)</p>
<p>space:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;<span class="comment">//如果负数 1/x  n = -n</span></span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            result = result *x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="2-快速幂算法"><a href="#2-快速幂算法" class="headerlink" title="2.快速幂算法"></a>2.快速幂算法</h3><p>time : O(logn)</p>
<p>space:O(logn)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;<span class="comment">//如果负数 1/x  n = -n</span></span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> quickPow(x,n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickPow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> half = quickPow(x,n/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  half * half;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  half * half * x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-快速幂算法-循环版"><a href="#3-快速幂算法-循环版" class="headerlink" title="3.快速幂算法-循环版"></a>3.快速幂算法-循环版</h3><p>time : O(logN)</p>
<p>space:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n;i&gt;=<span class="number">0</span>;i/=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                result *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17. 打印从1到最大的n位数"></a>17. 打印从1到最大的n位数</h2><blockquote>
<p>难度简单10</p>
<p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = <span class="number">1</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>直接用Math.pow(10,n)  计算出大小 比如n =  2 Math.pow(10,2)  100 -1  = 99</p>
<p>time:O(n)</p>
<p>space:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span> [(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,n) - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            arr[i] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18. 删除链表的节点"></a>18. 删除链表的节点</h2><blockquote>
<p>难度简单12收藏分享切换为英文关注反馈</p>
<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p><strong>注意：</strong>此题对比原题有改动</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-遍历法"><a href="#1-遍历法" class="headerlink" title="1.遍历法"></a>1.遍历法</h3><p>th:通过loop遍历 找到等于val的节点 将上一个节点和要删除节点的next节点相连接。</p>
<p>time:O(n)</p>
<p>time:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历查找到Node.val = val的结点</span></span><br><span class="line">        ListNode root  = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是头结点就是要删除的节点 直接用root.next 指向根节点  返回即可</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == val)&#123;</span><br><span class="line">            head = root.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(root.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.next.val == val)&#123;</span><br><span class="line">                root.next = root.next.next;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-双指针"><a href="#2-双指针" class="headerlink" title="2.双指针"></a>2.双指针</h3><p>th:一共两种情况 1. 头结点就是删除的节点 直接返回head.next 即可。</p>
<p>2.删除的节点在链表中某个位置。 一个pre节点  和 一个 cur节点  cur节点比pre节点快一步 找到删除即可。</p>
<p>time:O(n)</p>
<p>space:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是head节点 直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head.val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode pre = head, cur = head.next;</span><br><span class="line">        <span class="comment">//遍历寻找</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> &amp;&amp; cur.val != val)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20.表示数值的字符串"></a>20.表示数值的字符串</h2><blockquote>
<h4 id="面试题20-表示数值的字符串"><a href="#面试题20-表示数值的字符串" class="headerlink" title="面试题20. 表示数值的字符串"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题20. 表示数值的字符串</a></h4><p>难度中等9</p>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”及”-1E-16”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p>
<p>注意：本题与主站 65 题相同：<a href="https://leetcode-cn.com/problems/valid-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-number/</a></p>
</blockquote>
<p>正则表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[] : 字符集合</span><br><span class="line">() : 分组</span><br><span class="line">?  : 重复0-1次</span><br><span class="line">+  ：重复1-n次</span><br><span class="line">*  : 重复0-n次</span><br><span class="line">.  : 任意字符</span><br><span class="line">\\. :转义后的.</span><br><span class="line">\\d :数字</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        String str=<span class="string">"^[+|-]?((\\d+\\.?)|(\\d*\\.\\d+))([E|e][+|-]?\\d+)?$"</span>;</span><br><span class="line">        <span class="keyword">return</span> s.trim().matches(str);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21. 调整数组顺序使奇数位于偶数前面"></a>21. 调整数组顺序使奇数位于偶数前面</h2><blockquote>
<p>难度简单12</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1.双指针"></a>1.双指针</h3><p>思路:i指向前边，j指向后边 i从前往后移动 当不是奇数的时候就跳出  j从后往前移动不是偶数的时候跳出。i 和 j下标所在的位置数据进行交换。终止条件是i&lt;j 多次交换以后 前边的数据就是奇数，后边的数据是偶数。</p>
<p>time :O(n)</p>
<p>space:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//参数判断</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = nums.length-<span class="number">1</span>,temp;</span><br><span class="line">        <span class="comment">//while</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="comment">//i++ 查找不是奇数跳出</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; ((nums[i] &amp; <span class="number">1</span>) == <span class="number">1</span>)) i++;</span><br><span class="line">            <span class="comment">//j-- 查找不是偶数的跳出</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; ((nums[j] &amp; <span class="number">1</span>) == <span class="number">0</span>)) j--; </span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            temp = nums[i];  </span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22. 链表中倒数第k个节点"></a>22. 链表中倒数第k个节点</h2><blockquote>
<h4 id="面试题22-链表中倒数第k个节点"><a href="#面试题22-链表中倒数第k个节点" class="headerlink" title="面试题22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">面试题22. 链表中倒数第k个节点</a></h4><p>难度简单23收藏分享切换为英文关注反馈</p>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-双指针-快慢指针"><a href="#1-双指针-快慢指针" class="headerlink" title="1.双指针-快慢指针"></a>1.双指针-快慢指针</h3><p>思路:一般这种题 我们可以用双指针中的快慢指针进行解决，首先定义一个快指针fastNode 先让fastNode走k步，然后定义一个慢指针 慢指针和快指针同时走 当fastNode走到指针头就停止，这时slowNode就在倒数第k个节点</p>
<p>time:O(n)</p>
<p>space：O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个fastNode 先走k步 在定义一个slowNode slowNode和fastNode同时走 当fastNode走到头</span></span><br><span class="line">    <span class="comment">//此时slowNode就走到了倒数第k个节点 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode fastNode = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            fastNode = fastNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode slowNode = head;</span><br><span class="line">        <span class="keyword">while</span>(fastNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fastNode = fastNode.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24.反转链表"></a>24.反转链表</h2><blockquote>
<h4 id="面试题24-反转链表"><a href="#面试题24-反转链表" class="headerlink" title="面试题24. 反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">面试题24. 反转链表</a></h4><p>难度简单28收藏分享切换为英文关注反馈</p>
<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：链表的反转，通常需要定义一个前置节点 遍历链表中所有结点。</p>
<p>time:O(n)</p>
<p>space:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路 每次遍历 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = head,pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = cur.next;<span class="comment">//设置当当前节点next 赋值到next上</span></span><br><span class="line">            cur.next = pre;<span class="comment">//cur.next = null</span></span><br><span class="line">            pre = cur; <span class="comment">//当前节点指向pre</span></span><br><span class="line">            cur = next;<span class="comment">//指向下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25.合并两个排序的链表"></a>25.合并两个排序的链表</h2><blockquote>
<h4 id="面试题25-合并两个排序的链表"><a href="#面试题25-合并两个排序的链表" class="headerlink" title="面试题25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">面试题25. 合并两个排序的链表</a></h4><p>难度简单17</p>
<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-迭代"><a href="#1-迭代" class="headerlink" title="1.迭代"></a>1.迭代</h3><p>时间复杂度:O(m+n)</p>
<p>空间复杂度:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//头结点</span></span><br><span class="line">       ListNode cur = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">       ListNode head = cur;</span><br><span class="line">       <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="comment">//l1链表</span></span><br><span class="line">           <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">               cur.next = l1;</span><br><span class="line">               l1 = l1.next;<span class="comment">//l1链表移动</span></span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               cur.next = l2;</span><br><span class="line">               l2 = l2.next;<span class="comment">//l2链表移动</span></span><br><span class="line">           &#125;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       cur.next = (l1 !=<span class="keyword">null</span>  ? l1 : l2);</span><br><span class="line">       <span class="keyword">return</span> head.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26.树的子结构"></a>26.树的子结构</h2><blockquote>
<h4 id="面试题26-树的子结构"><a href="#面试题26-树的子结构" class="headerlink" title="面试题26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">面试题26. 树的子结构</a></h4><p>难度中等37</p>
<p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>例如:<br>给定的树 A:</p>
<p><code>3    / \   4   5  / \ 1   2</code><br>给定的树 B：</p>
<p><code>4   / 1</code><br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路:</p>
<p>//1.若A的根节点和B的根节点相同，则递归调用 </p>
<p>//      a.终止条件 b == null 说明b遍历完毕 返回true<br>//      b.a == null a.val != b.val 说明a树遍历结束没有找到b的开始根节点<br>//      c.递归调用a的左节点和b的左节点 或者a的右节点 和 b的右节点<br>//2.调用A的做节点和B子树比较  重复上述步骤<br>//3.A的右节点和B子树比较  重复1</p>
<p>时间复杂度:O(MN)</p>
<p>空间复杂度:O(M)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.若A的根节点和B的根节点相同，则递归调用 </span></span><br><span class="line">    <span class="comment">//  a.终止条件 b == null 说明b遍历完毕 返回true</span></span><br><span class="line">    <span class="comment">//  b.a == null a.val != b.val 说明a树遍历结束没有找到b的开始根节点</span></span><br><span class="line">    <span class="comment">//  c.递归调用a的左节点和b的左节点 或者a的右节点 和 b的右节点</span></span><br><span class="line">    <span class="comment">//2.调用A的做节点和B子树比较  重复上述步骤</span></span><br><span class="line">    <span class="comment">//3.A的右节点和B子树比较  重复1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (A != <span class="keyword">null</span> &amp;&amp; B != <span class="keyword">null</span> ) &amp;&amp; (recur(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode a,TreeNode b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.val != b.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(a.left,b.left) &amp;&amp; recur(a.right,b.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27.二叉树的镜像"></a>27.二叉树的镜像</h2><blockquote>
<h4 id="面试题27-二叉树的镜像"><a href="#面试题27-二叉树的镜像" class="headerlink" title="面试题27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">面试题27. 二叉树的镜像</a></h4><p>难度简单15</p>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<p><code>4   /   \  2     7 / \   / \1   3 6   9</code><br>镜像输出：</p>
<p><code>4   /   \  7     2 / \   / \9   6 3   1</code></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><p>时间复杂度:O(n) 建立二叉树的所有结点遍历一遍</p>
<p>空间复杂度:O(n) 最坏情况下 二叉树退化成链表，需要n个存储空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.暂存左节点</span></span><br><span class="line">   <span class="comment">//2.递归遍历右节点。</span></span><br><span class="line">   <span class="comment">//  a.右节点不为空继续下一层</span></span><br><span class="line">   <span class="comment">//  b.右节点为空 直接作为根节点的左节点。</span></span><br><span class="line">   <span class="comment">//3.递归遍历左节点</span></span><br><span class="line">   <span class="comment">//  a.左节点不为空继续下一层</span></span><br><span class="line">   <span class="comment">//  b.右节点为空 直接作为根节点的右节点。</span></span><br><span class="line">   <span class="comment">// 如此反复就可以修改。 </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//递归</span></span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       TreeNode temp = root.left;</span><br><span class="line">       root.left = mirrorTree(root.right);</span><br><span class="line">       root.right = mirrorTree(temp);</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-使用栈"><a href="#2-使用栈" class="headerlink" title="2.使用栈"></a>2.使用栈</h3><p>时间复杂度:O(n)  遍历一下结点的个数</p>
<p>空间复杂度:O(n)  存储所有结点的次数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.根节点存储到stack中</span></span><br><span class="line">    <span class="comment">//2.当stack 不为null 将根节点pop出来。</span></span><br><span class="line">    <span class="comment">//  a.如果root.left不为null stack.push -&gt; root.left</span></span><br><span class="line">    <span class="comment">//  b.如果root.right不为null stack.push -&gt; root.right</span></span><br><span class="line">    <span class="comment">//3.暂存left节点 </span></span><br><span class="line">    <span class="comment">//  a.交换左右节点 依次循环遍历。</span></span><br><span class="line">    <span class="comment">//返回根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode root2 = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(root2.left != <span class="keyword">null</span>) stack.push(root2.left);</span><br><span class="line">            <span class="keyword">if</span>(root2.right != <span class="keyword">null</span>) stack.push(root2.right);</span><br><span class="line">            TreeNode tmp = root2.left;</span><br><span class="line">            root2.left = root2.right;</span><br><span class="line">            root2.right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28.对称的二叉树"></a>28.对称的二叉树</h2><blockquote>
<h4 id="面试题28-对称的二叉树"><a href="#面试题28-对称的二叉树" class="headerlink" title="面试题28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题28. 对称的二叉树</a></h4><p>难度简单25</p>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<p><code>1   / \  2   2 / \ / \3  4 4  3</code><br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<p><code>1   / \  2   2   \   \   3    3</code></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-递归-1"><a href="#1-递归-1" class="headerlink" title="1.递归"></a>1.递归</h3><p>时间复杂度:O(n)</p>
<p>空间复杂度:O(n)  最差情况下 二叉树退化成链表，系统使用O(n)大小的栈空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line">    <span class="comment">//1.如果root == null 返回 true</span></span><br><span class="line">    <span class="comment">//2.否则调用左右节点递归遍历</span></span><br><span class="line">    <span class="comment">//  a.root.left == null &amp;&amp; root.right == null 返回true</span></span><br><span class="line">    <span class="comment">//  b.root.left == null || root.right == null || root.left.val != root.right.val  返回false</span></span><br><span class="line">    <span class="comment">//  c.递归下一层 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  (root == <span class="keyword">null</span> ) ? <span class="keyword">true</span> : recur(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode left,TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span> || left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(left.left,right.right) &amp;&amp; recur(left.right,right.left);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29.顺时针打印矩阵"></a>29.顺时针打印矩阵</h2><blockquote>
<h4 id="面试题29-顺时针打印矩阵"><a href="#面试题29-顺时针打印矩阵" class="headerlink" title="面试题29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">面试题29. 顺时针打印矩阵</a></h4><p>难度简单25</p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>时间复杂度:O(m*n)</p>
<p>空间复杂度:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="comment">//由外向内  左-》右  上-》下  右-》左  下-》上</span></span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = matrix[<span class="number">0</span>].length-<span class="number">1</span>,t = <span class="number">0</span>,b = matrix.length - <span class="number">1</span>,x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span> [(r+<span class="number">1</span>) * (b+<span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r;i++) arr[x++] = matrix[t][i]; <span class="comment">//left to right</span></span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &lt;= b ;i++) arr[x++] = matrix[i][r]; <span class="comment">// top to bottom</span></span><br><span class="line">            <span class="keyword">if</span>(l &gt; --r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i&gt;= l ;i--) arr[x++] = matrix[b][i]; <span class="comment">// right to left</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt; --b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = b;i &gt;= t;i--) arr[x++] = matrix[i][l];<span class="comment">//buttom to top</span></span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30.包含min函数的栈"></a>30.包含min函数的栈</h2><blockquote>
<h4 id="面试题30-包含min函数的栈"><a href="#面试题30-包含min函数的栈" class="headerlink" title="面试题30. 包含min函数的栈"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">面试题30. 包含min函数的栈</a></h4><p>难度简单12</p>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路:一个数据栈 一个最小值栈 在push的时候，将最小值存储到最小值栈中，pop的时候  直接pop出 当最小值栈中数据为空 将最大值添加进去。</p>
<p>时间复杂度:o(1)</p>
<p>空间复杂度:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; dataStack;</span><br><span class="line">   Stack&lt;Integer&gt; minStack;</span><br><span class="line">   <span class="keyword">int</span> minValue;</span><br><span class="line">   <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       dataStack = <span class="keyword">new</span> Stack();</span><br><span class="line">       minStack = <span class="keyword">new</span> Stack();</span><br><span class="line">       minValue = Integer.MAX_VALUE;</span><br><span class="line">   &#125;   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">       dataStack.push(x);</span><br><span class="line">       minValue = Math.min(x,minValue);</span><br><span class="line">       minStack.push(minValue);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       dataStack.pop();</span><br><span class="line">       minStack.pop();</span><br><span class="line">       minValue = minStack.isEmpty() ? Integer.MAX_VALUE : minStack.peek();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> minValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31.栈的压入、弹出序列"></a>31.栈的压入、弹出序列</h2><blockquote>
<h4 id="面试题31-栈的压入、弹出序列"><a href="#面试题31-栈的压入、弹出序列" class="headerlink" title="面试题31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">面试题31. 栈的压入、弹出序列</a></h4><p>难度中等27</p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>th:用栈模拟</p>
<p>time:O(n)</p>
<p>space：O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用stack存储pushed的数据 poped pop 如果相等stack.pop</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历pushed</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,len = pushed.length ; i &lt; len;i++)&#123; </span><br><span class="line">            stack.push(pushed[i]);</span><br><span class="line">            <span class="comment">//如果pushed 和  popped 相等  stack pop</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; index &lt; len &amp;&amp; stack.peek() == popped[index])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果栈为null 是 </span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="32-1-从上到下打印二叉树"><a href="#32-1-从上到下打印二叉树" class="headerlink" title="32-1 从上到下打印二叉树"></a>32-1 从上到下打印二叉树</h2><blockquote>
<h4 id="面试题32-I-从上到下打印二叉树"><a href="#面试题32-I-从上到下打印二叉树" class="headerlink" title="面试题32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题32 - I. 从上到下打印二叉树</a></h4><p>难度中等10</p>
<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>th：一个队列存储遍历的节点，先存储root结点，从队列中取出来，如果不为null 将左子节点 和右子节点分别存储起来。依次循环遍历。先存储左子节点 在存储有子节点 。层序遍历。</p>
<p>time:O(n)</p>
<p>space:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个队列存储结点，</span></span><br><span class="line">   <span class="comment">//list存储值 </span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       queue.add(root);</span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">           <span class="keyword">while</span>(cnt-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">               TreeNode t = queue.poll();</span><br><span class="line">               <span class="keyword">if</span>(t == <span class="keyword">null</span>)&#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               list.add(t.val);</span><br><span class="line">               queue.add(t.left);<span class="comment">//左子节点</span></span><br><span class="line">               queue.add(t.right);<span class="comment">//右子节点</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> [] ret = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">           ret[i] = list.get(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="32-2-从上到下打印二叉树-II"><a href="#32-2-从上到下打印二叉树-II" class="headerlink" title="32-2 从上到下打印二叉树 II"></a>32-2 从上到下打印二叉树 II</h2><blockquote>
<h4 id="面试题32-II-从上到下打印二叉树-II"><a href="#面试题32-II-从上到下打印二叉树-II" class="headerlink" title="面试题32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">面试题32 - II. 从上到下打印二叉树 II</a></h4><p>难度简单17</p>
<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">       recur(root,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">       <span class="comment">//终止条件</span></span><br><span class="line">       <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(list.size()&lt;=k)&#123;</span><br><span class="line">               list.add(<span class="keyword">new</span> ArrayList());</span><br><span class="line">           &#125;</span><br><span class="line">           list.get(k).add(root.val);</span><br><span class="line">           recur(root.left,k+<span class="number">1</span>);</span><br><span class="line">           recur(root.right,k+<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-队列-迭代"><a href="#2-队列-迭代" class="headerlink" title="2.队列+迭代"></a>2.队列+迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加根节点</span></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(cnt-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode t = queue.poll();<span class="comment">//弹出首节点</span></span><br><span class="line">                <span class="keyword">if</span>(t == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(t.val);</span><br><span class="line">                queue.add(t.left);</span><br><span class="line">                queue.add(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(list.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                result.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="32-3-从上到下打印二叉树-III"><a href="#32-3-从上到下打印二叉树-III" class="headerlink" title="32-3 从上到下打印二叉树 III"></a>32-3 从上到下打印二叉树 III</h2><blockquote>
<h4 id="面试题32-III-从上到下打印二叉树-III"><a href="#面试题32-III-从上到下打印二叉树-III" class="headerlink" title="面试题32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">面试题32 - III. 从上到下打印二叉树 III</a></h4><p>难度中等15</p>
<p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路:其实和前边的相同 添加一个标志位 第一次不需要反转，第二次需要反转，第三次不需要反转，依序就可以反转。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">boolean</span> reverse = <span class="keyword">false</span>;<span class="comment">//设置是否需要反转</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(cnt-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode t = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(t == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(t.val);</span><br><span class="line">                queue.add(t.left);</span><br><span class="line">                queue.add(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(reverse)&#123;</span><br><span class="line">                Collections.reverse(list);</span><br><span class="line">            &#125;</span><br><span class="line">            reverse = !reverse;</span><br><span class="line">            <span class="keyword">if</span>(list.size() != <span class="number">0</span>)</span><br><span class="line">                result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/22/Tree/">Tree</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-22</time><div class="content"><p>[TOC]</p>
<p><img src="e://pic/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20200329191409.png" alt=""></p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h2><blockquote>
<p>给定一个二叉树，返回它的中序 遍历。</p>
<p>示例:</p>
<p>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3</p>
<p>输出: [1,3,2]</p>
</blockquote>
<h3 id="1-递归法"><a href="#1-递归法" class="headerlink" title="1.递归法"></a>1.递归法</h3><p>我们知道二叉树的遍历有前序遍历 中序遍历 后序遍历。</p>
<p>前序遍历 :根左右</p>
<p>中序遍历:左根右</p>
<p>后序遍历:左右根</p>
<p>时间复杂度:O(n)。递归函数 T(n) = 2*T(n/2)+1 </p>
<p>空间辅助度:最坏情况下需要空间O(n),平均情况为O(log N)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       helper(root,result);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="comment">//左</span></span><br><span class="line">           <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               helper(root.left,result);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//中</span></span><br><span class="line">           result.add(root.val);</span><br><span class="line">           <span class="comment">//右</span></span><br><span class="line">           <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               helper(root.right,result);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-基于栈的遍历"><a href="#2-基于栈的遍历" class="headerlink" title="2.基于栈的遍历"></a>2.基于栈的遍历</h3><p>用一个栈接收访问的路径 因为栈是先进后出 所以最后访问的元素就是最先遍历的元素。先查找左节点 左节点完毕后 输出，查找右节点。</p>
<p>时间复杂度:O(n)</p>
<p>空间复杂度:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">       <span class="comment">//获取根节点 </span></span><br><span class="line">       TreeNode curr = root;</span><br><span class="line">       <span class="comment">//如果当前节点不为null or 栈不为null 说明还有节点没有遍历完</span></span><br><span class="line">       <span class="keyword">while</span>(curr != <span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">           <span class="comment">//先将左节点push 进</span></span><br><span class="line">           <span class="keyword">if</span>(curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.push(curr);</span><br><span class="line">               curr = curr.left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//后push的 先输出</span></span><br><span class="line">           curr = stack.pop();</span><br><span class="line">           result.add(curr.val);</span><br><span class="line">           <span class="comment">//查看当前节点的右节点 </span></span><br><span class="line">           curr = curr.right;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h2><blockquote>
<p>给定一个二叉树，返回它的 前序 遍历。</p>
<p> 示例:</p>
<p>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3 </p>
<p>输出: [1,2,3]</p>
</blockquote>
<h3 id="1-递归法-1"><a href="#1-递归法-1" class="headerlink" title="1.递归法"></a>1.递归法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        helper(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//根</span></span><br><span class="line">            result.add(root.val);</span><br><span class="line">            <span class="comment">//左</span></span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                helper(root.left,result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右</span></span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                helper(root.right,result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-基于栈的遍历-1"><a href="#2-基于栈的遍历-1" class="headerlink" title="2.基于栈的遍历"></a>2.基于栈的遍历</h3><p>其实我们使用递归去输出二叉树的遍历，计算机也是利用栈进行操作，我们可以模拟栈进行操作、</p>
<p>栈是先进后出的线性结构。因此 前序遍历是根左右  应该先push rootNode 输出。剩下就是左右节点的遍历，应该先push右节点，然后在push左节点，这样在pop的时候 顺序就是左右。</p>
<p>时间复杂度:O(n) 相当于树进行了一次loop操作</p>
<p>空间复杂度:O(n) 用栈做临时空间存储。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先将头结点条件进去</span></span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="comment">//添加右节点 因为栈是先进后出 而前序遍历是根左右 所以右节点陷进去最后出来</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//添加左节点 </span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="590-N叉数的后序遍历"><a href="#590-N叉数的后序遍历" class="headerlink" title="590.N叉数的后序遍历"></a>590.N叉数的后序遍历</h2><blockquote>
<h4 id="590-N叉树的后序遍历"><a href="#590-N叉树的后序遍历" class="headerlink" title="590. N叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">590. N叉树的后序遍历</a></h4><p>难度简单58</p>
<p>给定一个 N 叉树，返回其节点值的<em>后序遍历</em>。</p>
<p>例如，给定一个 <code>3叉树</code> :</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" alt="img"></p>
<p>返回其后序遍历: <code>[5,6,3,2,4,1]</code>.</p>
</blockquote>
<h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><p>时间复杂度:O(n)</p>
<p>空间复杂度:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="comment">//1.一个LikedList链表存储数值</span></span><br><span class="line">    <span class="comment">//2.递归调用</span></span><br><span class="line">    <span class="comment">// a.如果根节点为null 返回</span></span><br><span class="line">    <span class="comment">// b.依次遍历根节点的孩子节点 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        recur(root);</span><br><span class="line">        <span class="keyword">return</span> linkedList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node node : root.children)&#123;</span><br><span class="line">            recur(node);</span><br><span class="line">        &#125;</span><br><span class="line">        linkedList.add(root.val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-栈迭代"><a href="#2-栈迭代" class="headerlink" title="2.栈迭代"></a>2.栈迭代</h3><p>时间复杂度:O(n)</p>
<p>空间复杂度:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.N叉树的后序遍历 左右根 </span></span><br><span class="line">  <span class="comment">// 2.用一个链表存储数据 每次添加首节点 依次往后移动</span></span><br><span class="line">  <span class="comment">// 3.将root节点push到栈中 遍历左右子节点。如果不为null 继续</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">      LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">      Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">      stack.push(root);</span><br><span class="line">      <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">          root = stack.pop();</span><br><span class="line">          linkedList.offerFirst(root.val);<span class="comment">//先进排在最后</span></span><br><span class="line">          <span class="keyword">for</span>(Node node : root.children)&#123;</span><br><span class="line">              stack.push(node);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> linkedList;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="589-N叉树的前序遍历"><a href="#589-N叉树的前序遍历" class="headerlink" title="589.N叉树的前序遍历"></a>589.N叉树的前序遍历</h2><blockquote>
<h4 id="589-N叉树的前序遍历-1"><a href="#589-N叉树的前序遍历-1" class="headerlink" title="589. N叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">589. N叉树的前序遍历</a></h4><p>难度简单71</p>
<p>给定一个 N 叉树，返回其节点值的<em>前序遍历</em>。</p>
<p>例如，给定一个 <code>3叉树</code> :</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" alt="img"></p>
<p>返回其前序遍历: <code>[1,3,5,6,2,4]</code>。</p>
</blockquote>
<h3 id="1-递归-1"><a href="#1-递归-1" class="headerlink" title="1.递归"></a>1.递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历  根左右  递归调用即可。</span></span><br><span class="line">    <span class="comment">//先将节点的值存储到linkedList中</span></span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; linkedList = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList() : recur(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LinkedList&lt;Integer&gt; <span class="title">recur</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        linkedList.add(root.val);</span><br><span class="line">        <span class="keyword">for</span>(Node node : root.children)&#123;</span><br><span class="line">            recur(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> linkedList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-栈迭代-1"><a href="#2-栈迭代-1" class="headerlink" title="2.栈迭代"></a>2.栈迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line">   <span class="comment">//前序遍历 根-左-右</span></span><br><span class="line">   <span class="comment">//1.将根节点存储到stack中</span></span><br><span class="line">   <span class="comment">//2.逆序将子节点添加到栈中 比如 push的顺序为 2 3 4  则输出的顺序为 4 3 2 </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">       stack.push(root);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">           root = stack.pop();</span><br><span class="line">           list.add(root.val);</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=root.children.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">               stack.push(root.children.get(i));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="429-N叉数的层序遍历"><a href="#429-N叉数的层序遍历" class="headerlink" title="429.N叉数的层序遍历"></a>429.N叉数的层序遍历</h2><blockquote>
<h4 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429. N叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">429. N叉树的层序遍历</a></h4><p>难度中等76</p>
<p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。 (即从左到右，逐层遍历)。</p>
<p>例如，给定一个 <code>3叉树</code> :</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" alt="img"></p>
<p>返回其层序遍历:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">     [3,2,4],</span><br><span class="line">     [5,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-队列实现广度优先搜索"><a href="#1-队列实现广度优先搜索" class="headerlink" title="1.队列实现广度优先搜索"></a>1.队列实现广度优先搜索</h3><p>time:O(n)</p>
<p>space:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.用队列实现广度优先搜索</span></span><br><span class="line">   <span class="comment">//2.一个list 一个queue  list存储节点的值  queue存储每一层遍历的节点。</span></span><br><span class="line">   <span class="comment">//3.当queue != null 的时候，遍历当前层。</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList();<span class="comment">//存储每一层的结点值</span></span><br><span class="line">       queue.add(root);</span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">           List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">int</span> size = queue.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">               Node node = queue.poll();</span><br><span class="line">               level.add(node.val);</span><br><span class="line">               queue.addAll(node.children);</span><br><span class="line">           &#125;</span><br><span class="line">           list.add(level);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/22/Stack/">Stack</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-22</time><div class="content"><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h2><blockquote>
<p>难度简单1475</p>
<p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用栈   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="comment">//如果是 [ &#123; ( push到Stack中</span></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'&#123;'</span> || c == <span class="string">'['</span> || c == <span class="string">'('</span>)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将Stack中 [  &#123; ( pop出来 和 c中的遍历 如果相等就消去一对</span></span><br><span class="line">                Character ch = stack.pop();</span><br><span class="line">                <span class="keyword">boolean</span> a = (c == <span class="string">'&#125;'</span> &amp;&amp; ch != <span class="string">'&#123;'</span>);</span><br><span class="line">                <span class="keyword">boolean</span> b = (c == <span class="string">']'</span> &amp;&amp; ch != <span class="string">'['</span>);</span><br><span class="line">                <span class="keyword">boolean</span> d = (c == <span class="string">')'</span> &amp;&amp; ch != <span class="string">'('</span>);</span><br><span class="line">                <span class="keyword">if</span>(a || b || d)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后如果栈中为null 说明 符号正确</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n)</p>
<p>时间复杂度:O(n^2/2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            length = s.length();</span><br><span class="line">            s = s.replace(<span class="string">"()"</span>,<span class="string">""</span>).replace(<span class="string">"[]"</span>,<span class="string">""</span>).replace(<span class="string">"&#123;&#125;"</span>,<span class="string">""</span>);</span><br><span class="line">        &#125;<span class="keyword">while</span>(length != s.length());</span><br><span class="line">        <span class="keyword">return</span> s.isBlank();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155.最小栈"></a>155.最小栈</h2><blockquote>
<p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) – 将元素 x 推入栈中。<br>pop() – 删除栈顶的元素。<br>top() – 获取栈顶元素。<br>getMin() – 检索栈中的最小元素。<br>示例:</p>
<p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p>
</blockquote>
<p>time:O(1)</p>
<p>space:O(n)</p>
<p>th：最小栈的实现 一般通过两个栈来实现 一个数据栈 一个存储最小值的栈  在push和pop的时候 注意 push的时候 数据栈直接存储  但是对于minStack来说 需要比较得出最先栈的值  而pop的时候 需要进行判断是否会存在如果minStack为空的话需要 将Integer.max_value 存储 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">   Stack&lt;Integer&gt; dataStack;<span class="comment">//数据栈</span></span><br><span class="line">   Stack&lt;Integer&gt; minStack;<span class="comment">//最小值栈</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       dataStack = <span class="keyword">new</span> Stack();</span><br><span class="line">       minStack = <span class="keyword">new</span> Stack();</span><br><span class="line">       min = Integer.MAX_VALUE;<span class="comment">//存储一个最大值 用作比较</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">       dataStack.push(x);</span><br><span class="line">       min = Math.min(min,x);</span><br><span class="line">       minStack.add(min);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       dataStack.pop();</span><br><span class="line">       minStack.pop();</span><br><span class="line">       min = minStack.isEmpty() ? Integer.MAX_VALUE : minStack.peek();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> min;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84.柱状图中最大的矩形"></a>84.柱状图中最大的矩形</h2><blockquote>
<h4 id="84-柱状图中最大的矩形-1"><a href="#84-柱状图中最大的矩形-1" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></h4><p>难度困难509收藏分享切换为英文关注反馈</p>
<p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png" alt="img"></p>
<p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" alt="img"></p>
<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-暴力破解"><a href="#1-暴力破解" class="headerlink" title="1.暴力破解"></a>1.暴力破解</h3><p>思路</p>
<p>两层遍历确定每一层最大的面积，第三层循环确定每次最底的高， j-i+1 长 * 高 求出每次的面积</p>
<p>time:O(n^3)</p>
<p>space:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;heights.length;i++)&#123; <span class="comment">//多少轮</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;heights.length;j++)&#123; <span class="comment">//多少次</span></span><br><span class="line">              <span class="keyword">int</span> minHeigh = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;k++)<span class="comment">//每一次中最小值</span></span><br><span class="line">                  minHeigh = Math.min(minHeigh,heights[k]);</span><br><span class="line"></span><br><span class="line">              maxArea = Math.max(maxArea,minHeigh*(j-i+<span class="number">1</span>));<span class="comment">//每一次计算出最大值</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> maxArea;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-优化暴力"><a href="#2-优化暴力" class="headerlink" title="2.优化暴力"></a>2.优化暴力</h3><p>思路：每次利用之前的最低高</p>
<p>time:O(n^2)</p>
<p>space:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;heights.length;i++)&#123; <span class="comment">//多少轮</span></span><br><span class="line">            <span class="keyword">int</span> minHeigh = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;heights.length;j++)&#123; <span class="comment">//多少次</span></span><br><span class="line">                minHeigh = Math.min(minHeigh,heights[j]);</span><br><span class="line">                maxArea = Math.max(maxArea,minHeigh*(j-i+<span class="number">1</span>));<span class="comment">//每一次计算出最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3.栈"></a>3.栈</h3><p>time:O(n)</p>
<p>space:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">       Stack &lt; Integer &gt; stack = <span class="keyword">new</span> Stack &lt; &gt; ();</span><br><span class="line">       stack.push(-<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">int</span> maxarea = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; ++i) &#123;</span><br><span class="line">           <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span> &amp;&amp; heights[stack.peek()] &gt;= heights[i])</span><br><span class="line">               maxarea = Math.max(maxarea, heights[stack.pop()] * (i - stack.peek() - <span class="number">1</span>));</span><br><span class="line">           stack.push(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span>)</span><br><span class="line">           maxarea = Math.max(maxarea, heights[stack.pop()] * (heights.length - stack.peek() -<span class="number">1</span>));</span><br><span class="line">       <span class="keyword">return</span> maxarea;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/22/regular/">regular</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-22</time><div class="content"><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/22/Recursion/">Recursion</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-22</time><div class="content"><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h2><blockquote>
<h4 id="70-爬楼梯-1"><a href="#70-爬楼梯-1" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h4><p>难度简单943</p>
<p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><p>时间复杂度:O(2^n)</p>
<p>空间复杂度:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力破解</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> climbStairs(<span class="number">0</span>,n);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// i记录当前阶数  n代表目标阶数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(i&gt;n)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(i == n)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> climbStairs(i+<span class="number">1</span>,n)+climbStairs(i+<span class="number">2</span>,n);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-记忆化递归"><a href="#2-记忆化递归" class="headerlink" title="2.记忆化递归"></a>2.记忆化递归</h3><p>可以看到第一种解法 会出现重复计算。</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度:  O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记忆化递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] memo = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> climbStairs(<span class="number">0</span>,n,memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> n,<span class="keyword">int</span> [] memo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i] = climbStairs(i+<span class="number">1</span>,n,memo)+climbStairs(i+<span class="number">2</span>,n,memo);</span><br><span class="line">        <span class="keyword">return</span> memo[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3.动态规划"></a>3.动态规划</h3><p>time : O(n)</p>
<p>space：O(n)</p>
<p>用一个数组存储 n阶需要的步数，自底向上编程，先求出最开始的 一步一步向上求解。而递归虽然直接求解的是n阶的所需要的步数，但是由于不断地递归调用自身，也就先求解出最小的阶数，一步一步向上求解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划  -&gt;自底向上编程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( n ==  <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] =  <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] =  <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-斐波那契数列"><a href="#4-斐波那契数列" class="headerlink" title="4.斐波那契数列"></a>4.斐波那契数列</h3><p>时间复杂度:O(n)</p>
<p>空间复杂度:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//斐波那契数列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> second = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> third = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            third = first + second; <span class="comment">// 1 + 2</span></span><br><span class="line">            first = second; <span class="comment">// 2</span></span><br><span class="line">            second = third; <span class="comment">// 3</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h2><blockquote>
<h4 id="22-括号生成-1"><a href="#22-括号生成-1" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></h4><p>难度中等969</p>
<p>数字 <em>n</em> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 *<em>有效的 *</em>括号组合。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[</span><br><span class="line">       &quot;((()))&quot;,</span><br><span class="line">       &quot;(()())&quot;,</span><br><span class="line">       &quot;(())()&quot;,</span><br><span class="line">       &quot;()(())&quot;,</span><br><span class="line">       &quot;()()()&quot;</span><br><span class="line">     ]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>时间：O(2^n)</p>
<p>思路:如果递归生成括号，会出现很多无效的括号，因此 在递归的过程中过滤掉一些不符合条件的括号。规律就是 生成n 也就是2n个括号 由于都是小括号，因此 左括号 和右括号 应该是相等的。如果left &lt; n 继续 递归  由于一个右括号应该匹配一个左括号 当左括号 &gt; 右括号 递归  当left 和 right == n的时候就停止 返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;String&gt; result;<span class="comment">//存储结果</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       generate(<span class="string">""</span>,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//在recursion中过滤掉不符合条件的括号。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">(String str,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="comment">//终止条件</span></span><br><span class="line">       <span class="keyword">if</span>(left == n &amp;&amp; right == n)&#123;</span><br><span class="line">           result.add(str);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(left &lt; n)&#123;</span><br><span class="line">           generate(str+<span class="string">"("</span>,left+<span class="number">1</span>,right,n);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">           generate(str+<span class="string">")"</span>,left,right+<span class="number">1</span>,n);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/22/Queue/">Queue</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-22</time><div class="content"><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h2><blockquote>
<h4 id="239-滑动窗口最大值-1"><a href="#239-滑动窗口最大值-1" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></h4><p>难度困难290</p>
<p>给定一个数组 <em>nums*，有一个大小为 *k *的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 *k</em> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p><strong>进阶：</strong></p>
<p>你能在线性时间复杂度内解决此题吗？</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1.暴力法"></a>1.暴力法</h3><p>思路：我们可以将滑动窗口问题抽象化，一直移动那么最后的数据格式就是一个二维数组 for for 遍历找出每次滑动窗口的最大值存储起来，就可以了。首先是确定滑动窗口的次数。k是窗口的大小，n是长度   k = 3   n = 8   移动了6    <em>size = n - k +1</em>   外层循环是移动次数 内层循环开始条件是 i  随着移动次数增加， k = i   终止条件为 最终移动的次数 i + k  就到数组的最后了。剩下依次判断就可以了。</p>
<p>时间复杂度：O(N*K)  外层k次 内层N次</p>
<p>空间复杂度：O(n-k+1) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//参数判断</span></span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(length * k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//窗口移动的次数为length-k+1</span></span><br><span class="line">        <span class="keyword">int</span> [] array = <span class="keyword">new</span> <span class="keyword">int</span> [length-k+<span class="number">1</span>];  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length-k+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">          <span class="comment">//因为窗口每次都要移动 在i的基础上 增加 终止条件是i+k 说明到底</span></span><br><span class="line">          <span class="comment">//每一次loop 找出最大值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+k;j++)&#123;</span><br><span class="line">                max = Math.max(max,nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//该层的最大值</span></span><br><span class="line">            array[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-双端队列"><a href="#2-双端队列" class="headerlink" title="2.双端队列"></a>2.双端队列</h3><p>思路:使用队列进行存储每次窗口的最大值的下标，如果当前值最大 那么之前的所有值就可以清空了</p>
<p>ps : 1 3 4    4最大 所以在这个窗口期中4一直最大 1 3 就可以出队列。 </p>
<p>time:O(N) 队列的出队和入队是O(1)  只存在遍历n次数组中的数据</p>
<p>space:O(n)  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>  ArrayDeque&lt;Integer&gt; deq = <span class="keyword">new</span> ArrayDeque();<span class="comment">//存储下标值 比较大小</span></span><br><span class="line"><span class="keyword">private</span>  <span class="keyword">int</span> [] nums;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k == <span class="number">0</span>)&#123; <span class="comment">//参数判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;   <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    <span class="comment">//存储最大值的数组</span></span><br><span class="line">    <span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span> [n-k+<span class="number">1</span>];   <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        cleanDeq(i,k);</span><br><span class="line">        deq.addLast(i);</span><br><span class="line">        maxIndex = nums[maxIndex] &gt; nums[i] ? maxIndex : i;  </span><br><span class="line">   &#125;</span><br><span class="line">    arr[<span class="number">0</span>] = nums[maxIndex];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k;i&lt;n;i++)&#123;</span><br><span class="line">        cleanDeq(i,k);</span><br><span class="line">        deq.addLast(i);</span><br><span class="line">        arr[i-k+<span class="number">1</span>] = nums[deq.getFirst()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanDeq</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!deq.isEmpty() &amp;&amp; deq.getFirst() == i-k)&#123;<span class="comment">//删除前边数据较小的。或者无用数据</span></span><br><span class="line">        deq.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!deq.isEmpty() &amp;&amp; nums[i] &gt; nums[deq.getLast()])&#123; </span><br><span class="line">      <span class="comment">//如果当前值大于之前所有的值 则删除 </span></span><br><span class="line">        deq.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/22/LinkedList/">LinkedList</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-22</time><div class="content"><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>高频题</p>
<p><img src="e://pic/7430894_1569830509086_8E72661D2242C40ECD146E2DB6D88051.png" alt=""></p>
<h2 id="53-最大子序和？？"><a href="#53-最大子序和？？" class="headerlink" title="53. 最大子序和？？"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a>？？</h2><blockquote>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">crossSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftSubsum = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> currSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &gt; left - <span class="number">1</span>; --i) &#123;</span><br><span class="line">            currSum += nums[i];</span><br><span class="line">            leftSubsum = Math.max(leftSubsum, currSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rightSubsum = Integer.MIN_VALUE;</span><br><span class="line">        currSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p + <span class="number">1</span>; i &lt; right + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            currSum += nums[i];</span><br><span class="line">            rightSubsum = Math.max(rightSubsum, currSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftSubsum + rightSubsum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftSum = helper(nums, left, p);</span><br><span class="line">        <span class="keyword">int</span> rightSum = helper(nums, p + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">int</span> crossSum = crossSum(nums, left, right, p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(leftSum, rightSum), crossSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h2><blockquote>
<p>反转一个单链表。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现思路 </span></span><br><span class="line"><span class="comment">//在遍历列表时，将当前节点的next指针改为指向前一个元素，由于节点没有引用其上一个节点，因此必须实现存储前一个元素，在更改引用之前，还需要另一个指针来存储一个节点，不要忘记在最后返回新的头引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;<span class="comment">//设置一个null结点</span></span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode next = cur.next; <span class="comment">//记录ListNode节点</span></span><br><span class="line">        cur.next = prev;<span class="comment">//将cur.next 设置为null</span></span><br><span class="line">        prev = cur; <span class="comment">//当前节点赋值成prev</span></span><br><span class="line">        cur = next; <span class="comment">//当前节点设置成cur</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)O(n)，假设 n是列表的长度，时间复杂度是 O(n)O(n)。</li>
<li>空间复杂度：O(1)O(1)。</li>
</ul>
<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h2><blockquote>
<p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>示例 1：</p>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
</blockquote>
<p><img src="e:///pic/lc-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88.png" alt=""></p>
<h3 id="1-快慢指针"><a href="#1-快慢指针" class="headerlink" title="1.快慢指针"></a>1.快慢指针</h3><p>可以类比成两个运动员 在同一个环形运动场跑步，一个跑的快的 和 一个跑的慢的 在一定的时间内 快的一定会和慢的相遇，这个时候 就说明 有环存在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查是否链表中有环</span></span><br><span class="line">    <span class="comment">//思路:定义一个快指针 和 一个慢指针 慢指针一次走一步 快指针一次走两步</span></span><br><span class="line">    <span class="comment">//如果有环 一定会相遇。多次循环</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fastNode = head.next;</span><br><span class="line">        ListNode slowNode = head;</span><br><span class="line">        <span class="keyword">while</span> (fastNode!=<span class="keyword">null</span> &amp;&amp; fastNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fastNode = fastNode.next.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">            <span class="keyword">if</span> (slowNode == fastNode)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>分析:</p>
<p>时间复杂度:o(n)</p>
<p>1.第一种情况  链表不存在环 快慢指针分别到达尾部，其时间取决于列表的长度。O(n)</p>
<p>2.第二种情况  链表中存在环  在最糟糕的情形下，时间复杂度为 O(N+K)O(N+K)，也就是 O(n)</p>
<p>空间复杂度 o(1)</p>
<p>只是用了快慢指针两个结点。</p>
<h3 id="2-哈希表"><a href="#2-哈希表" class="headerlink" title="2.哈希表"></a>2.哈希表</h3><p>思路: 通过创建哈希表，遍历链表 将每次遍历的都存储到哈希表中 如果哈希表中有当前哈希值 说明 遍历到了环形处，说明是环形链表 否则的话 遍历完  说明不是环形链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set nodeSet = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeSet.contains(head))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nodeSet.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(n) 对于含有n个元素的链表 </p>
<p>空间复杂度:   o(n) 最坏情况下 全部添加 所有取决于哈希表中的元素数目</p>
<h2 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23.合并K个排序链表"></a>23.合并K个排序链表</h2><blockquote>
<p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p>示例:</p>
<p>输入:<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
</blockquote>
<h3 id="1-不使用递归"><a href="#1-不使用递归" class="headerlink" title="1.不使用递归"></a>1.不使用递归</h3><p>基本思路：我们可以使用分治思想 来解决这个问题。当一个链表集合中需要合并并排序。我们可以假设只有2个 每次合并两个。两个合并一个。这样就可以获取到最终的结果。</p>
<p>第一次将list[0]与list[len-1]合并 2次list[1]与list[len-2] 经过 for循环一次后。可以等到一半的list链表结合。在依次len = len/2; 依次合并 就可以获取到下标为0的为头结点的这个链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并两个有序的链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = lists.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">                lists[i] = merageKList(lists[i],lists[len-<span class="number">1</span>-i]);</span><br><span class="line">            &#125;</span><br><span class="line">            len = (len+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并两个有序的链表 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merageKList</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode listNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode head = listNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.data &lt; l2.data) &#123;</span><br><span class="line">                head.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head.next = l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listNode.next; <span class="comment">//note 注意返回的不是head 返回head 会带有 -1这个结点的值 只需要后边的值 牛掰思想</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：整体时间复杂度为O(N*log(k)), k为链表个数，N为链表平均长度。</p>
<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 示例: </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F; Related Topics 链表</span><br></pre></td></tr></table></figure>

<h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><p>thinking: 使用递归的方法  每一次递归都交换一对节点，用firstNode.next 记录上一次节点交换后的首节点。secondNode节点作为首节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if the list has no node or has only one node left</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Nodes to be swapped</span></span><br><span class="line">        ListNode firstNode = head;</span><br><span class="line">        ListNode secondNode = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//swapping</span></span><br><span class="line">        firstNode.next = swapPairs(secondNode.next);</span><br><span class="line">        secondNode.next = firstNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Now the head is the second node</span></span><br><span class="line">        <span class="keyword">return</span> secondNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)    O(N)，其中 N 指的是链表的节点数量。</li>
<li>空间复杂度：O(N)    O(N)，递归过程使用的堆栈空间。</li>
</ul>
<h4 id="递归简洁版"><a href="#递归简洁版" class="headerlink" title="-递归简洁版"></a>-递归简洁版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ((head == <span class="keyword">null</span>)||(head.next == <span class="keyword">null</span>))</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       ListNode n = head.next;</span><br><span class="line">       head.next = swapPairs(head.next.next);</span><br><span class="line">       n.next = head;</span><br><span class="line">       <span class="keyword">return</span> n;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-迭代法"><a href="#2-迭代法" class="headerlink" title="2.迭代法"></a>2.迭代法</h3><p>thinking：定义一个前驱节点，记录每次交换后的节点变化</p>
<p>head节点和pre节点每次交换完成后重置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">     *  迭代法</span></span><br><span class="line"><span class="comment">     *  1.定义一个前驱节点，用以记录每次交换后的元素的前置节点</span></span><br><span class="line"><span class="comment">     *  2.交换</span></span><br><span class="line"><span class="comment">     *  3.head 节点 和pre节点重置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((head!=<span class="keyword">null</span>) &amp;&amp; (head.next !=<span class="keyword">null</span>))&#123;</span><br><span class="line"></span><br><span class="line">            ListNode firstNode = head;</span><br><span class="line">            ListNode secondNode = head.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//swap</span></span><br><span class="line">            pre.next = secondNode;<span class="comment">//-1 -&gt; 2</span></span><br><span class="line">            firstNode.next = secondNode.next;<span class="comment">// 1 -&gt; 3</span></span><br><span class="line">            secondNode.next = firstNode;</span><br><span class="line"></span><br><span class="line">            pre = firstNode;</span><br><span class="line">            head = firstNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)，其中 N 指的是链表的节点数量。</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25.K 个一组翻转链表"></a>25.K 个一组翻转链表</h2><blockquote>
<p>难度困难416</p>
<p>给你一个链表，每 *k *个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>*k *是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 *k *的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p><strong>示例：</strong></p>
<p>给你这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>当 *k *= 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>当 *k *= 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p><strong>说明：</strong></p>
<ul>
<li>你的算法只能使用常数的额外空间。</li>
<li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 迭代法</span></span><br><span class="line"><span class="comment">     * 1.链表分区已翻转 + 待翻转 + 未翻转部分</span></span><br><span class="line"><span class="comment">     * 2.翻转前确定翻转的范围 通过k来决定</span></span><br><span class="line"><span class="comment">     * 3.记录链表前驱和后继 方便翻转完成后，把已翻转和未翻转连接起来。</span></span><br><span class="line"><span class="comment">     * 4.初始化两个边路pre  end  pre &gt;代表待翻转链表的前驱，end代表待翻转的末尾。</span></span><br><span class="line"><span class="comment">     * 5.经过k次 end到达链表末尾。  记录待翻转链表的后继 next = end.next</span></span><br><span class="line"><span class="comment">     * 6.翻转链表，将三部分连接起来，然后重置pre 和 end 指针 进入下一个循环</span></span><br><span class="line"><span class="comment">     * 7.特殊情况 翻转部分长度不足k时，在定位end 完成后，end = null 已经到达末尾。</span></span><br><span class="line"><span class="comment">     * 8.时间复杂度为 O(n*K) 最好的情况为 O(n) 最差的情况未 O(n^2)</span></span><br><span class="line"><span class="comment">     * 9.空间复杂度为 O(1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode dumy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dumy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode pre = dumy;</span><br><span class="line">        ListNode end = dumy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (end.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//确定待翻转的范围</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                end = end.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (end == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ListNode start = pre.next;<span class="comment">//待翻转链表的开始位置</span></span><br><span class="line">            ListNode next = end.next;<span class="comment">//下一个待翻转链表的起始位置</span></span><br><span class="line"></span><br><span class="line">            end.next = <span class="keyword">null</span>;<span class="comment">//和后继待翻转链表断开</span></span><br><span class="line"></span><br><span class="line">            pre.next = reverse(start);</span><br><span class="line">            start.next = next;</span><br><span class="line">            pre = start;</span><br><span class="line"></span><br><span class="line">            end = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dumy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="comment">//假设 1 -&gt; 2 -&gt; 3</span></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = curr.next; <span class="comment">// next = 2   // next = 3</span></span><br><span class="line">            curr.next = pre;<span class="comment">// 1.next = null        // 3.next = 1</span></span><br><span class="line">            pre = curr;<span class="comment">// pre = 1;                 //  1 = 3</span></span><br><span class="line">            curr = next; <span class="comment">// curr = 2              // 3  = null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre; <span class="comment">//</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h2><blockquote>
<p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="1-迭代"><a href="#1-迭代" class="headerlink" title="1.迭代"></a>1.迭代</h3><p>th:主要是通过定义一个head节点 遍历两个链表就可以，最后一定会有一个链表没有遍历完 使用三目运算符进行算</p>
<p><strong>需要注意的点</strong>  因为head节点一直next next下去 所以应该定义一个root节点 作为根节点 head节点 一直next下去。返回的是root节点</p>
<p>time:O(m+n)</p>
<p>space:O(1) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    *思路 主要是通过定义一个head节点 遍历两个链表就可以，最后一定会有一个链表没有遍历完 使用三目运算符进行算</span></span><br><span class="line"><span class="comment">    notice 因为head节点一直next next下去 所以应该定义一个root节点 作为根节点 head节点 一直next下去。返回的是root节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span> || l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode root = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode head = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span> &amp;&amp; l2!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                head.next = l1;</span><br><span class="line">                l1 = l1.next; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                head.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head.next = (l1 == <span class="keyword">null</span> ? l2 : l1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-递归"><a href="#2-递归" class="headerlink" title="2.递归"></a>2.递归</h3><p>th：其实如果一个方法可以迭代就可以递归解决，但是递归代码虽然简洁 理解上比较难一些，递归代码无非就是 三点需要注意：1 终止条件 2. 业务逻辑 3.解决下一个子问题 也就是 调用自身。</p>
<p>time:O(m+n)</p>
<p>space:调用 mergeTwoLists 退出时 l1 和 l2 中每个元素都一定已经被遍历过了，所以 n + mn+m 个栈帧会消耗 O(n + m)O(n+m) 的空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(l1 == <span class="keyword">null</span> )&#123;</span><br><span class="line">           <span class="keyword">return</span> l2;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l2 ==  <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">           l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">           <span class="keyword">return</span> l2;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/22/Hash/">Hash</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-22</time><div class="content"><h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p><img src="e://pic/7430894_1569830476289_917532E4CCA96E15E5ABCCCBCA30C9F8.png" alt=""></p>
<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h2><blockquote>
<h4 id="242-有效的字母异位词-1"><a href="#242-有效的字母异位词-1" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">242. 有效的字母异位词</a></h4><p>难度简单173收藏分享切换为英文关注反馈</p>
<p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-依次遍历比较"><a href="#1-依次遍历比较" class="headerlink" title="1.依次遍历比较"></a>1.依次遍历比较</h3><p>思路:异位次的含义是 一个字符串中字母的顺序改变，但是个数不变 就是异位词。</p>
<p>比较长度 如果长度不相等 返回false 然后将两个字符串进行排序，时间复杂度为O(logN) </p>
<p>然后进行依次比较 如果不相等直接返回true  不好的一点是 排序使时间复杂度提高了。</p>
<p>time :O(NlogN)</p>
<p>space:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//time O(NlogN)  space O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//排序后比较</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> [] chs = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span> [] cht = t.toCharArray();</span><br><span class="line"></span><br><span class="line">        Arrays.sort(chs);</span><br><span class="line">        Arrays.sort(cht);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(chs,cht);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-哈希表"><a href="#2-哈希表" class="headerlink" title="2.哈希表"></a>2.哈希表</h3><p>思路：如果长度不同 返回false 定义一个数组 26  s.charAt(i)-‘a’ 存储进数组  对应的下标  t.charAt(i)-‘a’  不存储对应的下标。前者++  后者– 当最后数组为0是异位词，否则不是异位词。</p>
<p>time:O(n)</p>
<p>space:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//哈希表</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> [] alpha = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            alpha[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            alpha[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;alpha.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(alpha[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49.字母异位词分组"></a>49.字母异位词分组</h2><blockquote>
<h4 id="49-字母异位词分组-1"><a href="#49-字母异位词分组-1" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. 字母异位词分组</a></h4><p>难度中等309</p>
<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-排序数组分类"><a href="#1-排序数组分类" class="headerlink" title="1.排序数组分类"></a>1.排序数组分类</h3><p>时间复杂度:O(NK logK)</p>
<p>空间复杂度:O(NK)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span> || strs == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.按照排序</span></span><br><span class="line">        Map&lt;String,List&gt; ans = <span class="keyword">new</span> HashMap&lt;String,List&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">            <span class="keyword">char</span> [] chs = str.toCharArray();</span><br><span class="line">            Arrays.sort(chs);</span><br><span class="line">            String key = String.valueOf(chs);</span><br><span class="line">            <span class="keyword">if</span>(!ans.containsKey(key))</span><br><span class="line">                ans.put(key,<span class="keyword">new</span> ArrayList());</span><br><span class="line">            ans.get(key).add(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(ans.values());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/22/Array/">Array</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-22</time><div class="content"><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p>[TOC]</p>
<p>高频面试题</p>
<p><img src="e://pic/7430894_1569830591035_8361FA23DFD51FBD74ED3E8B998C124D.png" alt=""></p>
<h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h2><blockquote>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>:</p>
<ol>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ol>
</blockquote>
<h3 id="1-空间最优，操作局部优化（双指针）"><a href="#1-空间最优，操作局部优化（双指针）" class="headerlink" title="-1.空间最优，操作局部优化（双指针）"></a>-1.空间最优，操作局部优化（双指针）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要思路  loop 2 次  第一次将所有非0元素移动到应该在的地方。</span></span><br><span class="line"><span class="comment">//第二次将后面的全部设置为0 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> modifyIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[modifyIndex++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;modifyIndex&lt;nums.length;modifyIndex++)&#123;</span><br><span class="line">            nums[modifyIndex] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)</p>
<h3 id="2-一次loop"><a href="#2-一次loop" class="headerlink" title="2.一次loop"></a>2.一次loop</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">* 思路:快排的思想找到一个中间点的数 比如 -21 -23 4 5 0 找到一个midNum数 作为标尺 来计算</span></span><br><span class="line"><span class="comment">  * 因此 在本题中找出所有0 用0作为一个标尺 0左边的都是非0 右边是0  </span></span><br><span class="line"><span class="comment">  * 通过一个loop就可以了。</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length ; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">             nums[i] = nums[j];</span><br><span class="line">             nums[j++] = temp;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n)</p>
<h3 id="3-滚雪球"><a href="#3-滚雪球" class="headerlink" title="3.滚雪球"></a>3.滚雪球</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 滚雪球</span></span><br><span class="line"><span class="comment">     *  一次loop 记录0的元素，如果不为0 与前面的元素进行交换  直到最后。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ballSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                ballSize++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ballSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                nums[i-ballSize] = nums[i];</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n)</p>
<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h2><blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>示例 1：</p>
<p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
</blockquote>
<h3 id="1-暴力破解"><a href="#1-暴力破解" class="headerlink" title="1.暴力破解"></a>1.暴力破解</h3><p>思路:我们可以将问题简单化，一个2个台阶可以分成是走2步和走1步结果的和。依次调用这个函数。进行细化求解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( n== <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> climbStairs(n-<span class="number">1</span>)+climbStairs(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(2^n)  由于时间过程 提交失败 </p>
<p>空间复杂度：O(n)</p>
<h3 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="-2.动态规划"></a>-2.动态规划</h3><p>不难发现，这个问题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建，我们可以使用动态规划来解决这一问题。</p>
<p>dp[i]=dp[i−1]+dp[i−2]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> [] num = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      num[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">          num[i] = num[i-<span class="number">1</span>]+num[i-<span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> num[n];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-container-with-most-water"><a href="#11-container-with-most-water" class="headerlink" title="11.container-with-most-water"></a>11.container-with-most-water</h2><blockquote>
<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-枚举"><a href="#1-枚举" class="headerlink" title="1.枚举"></a>1.枚举</h3><p>思路:枚举 类似冒泡一样 遍历每个元素与另一个元素的大小 <strong>下标值为长   数组的值为宽</strong></p>
<p>时间复杂度:O(n^2)  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length-<span class="number">1</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> area = (j-i)*Math.min(height[i],height[j]);<span class="comment">//长*宽</span></span><br><span class="line">                maxArea = Math.max(maxArea,area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-左右夹逼"><a href="#2-左右夹逼" class="headerlink" title="-2.左右夹逼"></a>-2.左右夹逼</h3><p>思路:通过依次loop i从最前面开始 向右移动 j从最后面向前移动 每次比较 如果较小，继续寻找更大的。</p>
<p>时间复杂度:O(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int maxArea(int[] height) &#123;</span><br><span class="line">        int maxArea &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0,j &#x3D; height.length-1; i &lt; j ; ) &#123;</span><br><span class="line">            &#x2F;&#x2F;计算出最小的高</span><br><span class="line">            int minHeight &#x3D; height[i] &lt;height[j] ? height[i++] : height[j--];</span><br><span class="line">            int area &#x3D; (j-i+1)*minHeight;</span><br><span class="line">            maxArea &#x3D; Math.max(area,maxArea);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxArea;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.<a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">移除元素</a></h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</span><br><span class="line">* 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</span><br><span class="line">* 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line">* 示例 1:</span><br><span class="line">* 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3,</span><br><span class="line">* 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line">* 你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-拷贝覆盖"><a href="#1-拷贝覆盖" class="headerlink" title="1.拷贝覆盖"></a>1.拷贝覆盖</h3><p>主要思路:定义一个变量，对不重复的值计数。for循环完成。</p>
<p>存在的问题 就是值可以计算出当前不相同值，数组的值是不符合要求的。</p>
<p><strong>这种思路在移除元素较多时更适合使用，最极端的情况是全部元素都需要移除，遍历一遍结束即可</strong></p>
<p><strong>时间复杂度:O(n) 空间复杂度O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeElement3</span><span class="params">(<span class="keyword">int</span> [] nums,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num!=val)&#123;</span><br><span class="line">                nums[count++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-交换移除"><a href="#2-交换移除" class="headerlink" title="2.交换移除"></a>2.交换移除</h3><p>主要思路:用一个变量去记录数组的长度，然后处理两种情况，一种是当前的值等于val 就将数组中最后的值赋值给当前相同的值，m 用来不断减少数组的长度。否则的话 是另一种情况 如果不相等 直接i++ 判断下一个就可以。</p>
<p><strong>这种思路在移除元素较少时更适合使用，最极端的情况是没有元素需要移除，遍历一遍结束即可</strong></p>
<p>时间复杂度：O(n)，空间复杂度：O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeElement4</span><span class="params">(<span class="keyword">int</span> [] nums,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ) &#123;<span class="comment">//注意for 这里不能i++ i是用来确认哪些数据不是要寻找的</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val)&#123;</span><br><span class="line">                nums[i] = nums[m-<span class="number">1</span>];</span><br><span class="line">                m--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-双指针"><a href="#3-双指针" class="headerlink" title="3.双指针"></a>3.双指针</h3><p>实现思路:一个快指针 一个慢指针。用快指针来判断是否相等 不相等赋值给慢指针，慢指针的作用是来定位前面如果有重复的直接跳过去。</p>
<p>时间复杂度:o(n)</p>
<p>空间复杂度:o(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeElement5</span><span class="params">(<span class="keyword">int</span> [] nums,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j]!=val)&#123;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                i++;<span class="comment">//加1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果相等 不做 等待下标i来进行覆盖</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-双指针-要删除的元素很少时"><a href="#4-双指针-要删除的元素很少时" class="headerlink" title="4.双指针-要删除的元素很少时"></a>4.双指针-要删除的元素很少时</h3><p>实现思路:通过快慢指针 在一种比较极端的情况下。nums[1,2,3,5,4] val = 4 在最后才可以找到需要删除的元素，虽然nums中的值没有改变，但是通过m– 停止了循环 i=4。</p>
<p>当我们遇到 nums[i] = valnums[i]=val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。</p>
<p>时间复杂度:O(n)</p>
<p>空间复杂度:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeElement6</span><span class="params">(<span class="keyword">int</span> [] nums,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;m)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val)&#123;<span class="comment">//相当的话 直接将快指针元素赋值给慢指针</span></span><br><span class="line">                nums[i] = nums[m-<span class="number">1</span>];</span><br><span class="line">                m--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;<span class="comment">//不相等 直接跳过</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h2><blockquote>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p>示例 1:</p>
<p>输入: [1,3,5,6], 5<br>输出: 2</p>
</blockquote>
<h3 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h3><p>实现思路: 使用二分查找就可以了。如果使用for循环的话，时间复杂度为O(n) 但是使用二分查找 时间复杂度就下降了很多，因此 注意边界的控制。</p>
<p>1.当target与查询的mid值相等 返回</p>
<p>2.当mid的值大于target max = mid-1;</p>
<p>3.当mid的值小于target min = mid+1</p>
<p>时间复杂度:o(logn)</p>
<p>注意边界的控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (min&lt;=max)&#123;</span><br><span class="line">            <span class="comment">//如果找到</span></span><br><span class="line">            mid = (min+max)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">                min = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                max = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
</blockquote>
<h3 id="1-暴力破解-1"><a href="#1-暴力破解-1" class="headerlink" title="1.暴力破解"></a>1.暴力破解</h3><p>thinking:通过两次loop 就可以找到，但是时间复杂度为O(n^2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target-nums[i] == nums[j])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> []&#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException(<span class="string">"no find two sum !"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-哈希表"><a href="#2-哈希表" class="headerlink" title="-2.哈希表"></a>-2.哈希表</h3><p>thiking：将数组中元素值作为key 存储到hashmap中 然后取寻找。遍历就可以了。</p>
<p>时间复杂度:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       Map&lt;Integer,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           hashMap.put(nums[i],i);<span class="comment">//将值作为key 可以保证数据不会出现重复</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length ; i++) &#123;</span><br><span class="line">           <span class="keyword">int</span> num = target - nums[i];</span><br><span class="line">           <span class="keyword">if</span> (hashMap.containsKey(num) &amp;&amp; hashMap.get(num)!=i)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> []&#123;i,hashMap.get(num)&#125;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException(<span class="string">"no find!"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><blockquote>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
</blockquote>
<h3 id="1-暴力求解"><a href="#1-暴力求解" class="headerlink" title="1.暴力求解"></a>1.暴力求解</h3><p>thinking:通过三层loop  这里如果使用ArrryList 是有序 可重复，不能避免元素重复问题。但是使用</p>
<p>LikedHashSet就可以<strong>避免元素重复问题</strong>。</p>
<p>时间复杂度:O(n^3)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">       <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;=<span class="number">2</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">       Set&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> k = j+<span class="number">1</span>;k&lt;nums.length;k++)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(nums[i]+nums[j]+nums[k] == <span class="number">0</span>)&#123;</span><br><span class="line">                       List&lt;Integer&gt; list = Arrays.asList(nums[i],nums[j],nums[k]);</span><br><span class="line">                       result.add(list);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-哈希表-1"><a href="#2-哈希表-1" class="headerlink" title="2.哈希表"></a>2.哈希表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * hash slow</span></span><br><span class="line"><span class="comment">    * 1406 ms	46 MB</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; hashSolution(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> target = -nums[i];</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;(nums.length - i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = target - nums[j];</span><br><span class="line">            Integer exist = hashMap.get(v);</span><br><span class="line">            <span class="keyword">if</span> (exist != <span class="keyword">null</span>) &#123;</span><br><span class="line">                List&lt;Integer&gt; list = Arrays.asList(nums[i], exist, nums[j]);</span><br><span class="line">                list.sort(Comparator.naturalOrder());</span><br><span class="line">                result.add(list);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hashMap.put(nums[j], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-夹逼法"><a href="#3-夹逼法" class="headerlink" title="3.夹逼法"></a>3.夹逼法</h3><p>thingking:左右夹逼，三数求和 a+b+c = 0  等价于 a+b=c   将数组进行排序，将c固定 a设置到c的下一个问题，也就是head  b设置到最后一个位置 tail位置。  </p>
<p>第一次遍历c固定 head 和tail 分别向中间移动，判断如果-sum &lt; target 说明值大 因为是负数。所以tail 左移动，否则就是head右移动。如此一轮后 如果找不到，接着c++ head 和tail接着判断。</p>
<p>就可以找到。时间复杂度相对于上面两种是比较低的。</p>
<p>时间复杂度:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> || nums.length &lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//元素去重</span></span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> head = i+<span class="number">1</span>;<span class="comment">//左端</span></span><br><span class="line">            <span class="keyword">int</span> tail = nums.length-<span class="number">1</span>;<span class="comment">//右端</span></span><br><span class="line">            <span class="keyword">while</span> (head&lt;tail)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = -(nums[head]+nums[tail]);<span class="comment">//取负值</span></span><br><span class="line">                <span class="keyword">if</span> (sum == nums[i])&#123;</span><br><span class="line">                    List&lt;Integer&gt; list = 			Arrays.asList(nums[i],nums[head],nums[tail]);</span><br><span class="line">                    result.add(list);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sum&lt;=nums[i])&#123;</span><br><span class="line">                    tail--;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    head++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26.删除排序数组中的重复项"></a>26.删除排序数组中的重复项</h2><blockquote>
<p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:</p>
<p>给定数组 nums = [1,1,2], </p>
<p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<h3 id="1-双指针法"><a href="#1-双指针法" class="headerlink" title="1.双指针法"></a>1.双指针法</h3><p>th: 一个快指针 一个慢指针 慢指针记录不重复的个数以及下标的作用，而快指针如果和慢指针中元素中出现相等的情况 不用添加直接跳过。</p>
<p>时间复杂度:O(n)</p>
<p>空间复杂度：只是用到了 临时变量 所以O(1) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums.length &lt;<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">       <span class="comment">//双指针法</span></span><br><span class="line">       <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[j] != nums[i])&#123;  </span><br><span class="line">               i++;</span><br><span class="line">               nums[i] = nums[j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> i+<span class="number">1</span>;<span class="comment">//因为i从零 所以实际上不重复的个数为i+1</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>##189.旋转数组</p>
<blockquote>
<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p>
<p>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]</p>
</blockquote>
<h3 id="1-暴力求解-1"><a href="#1-暴力求解-1" class="headerlink" title="1.暴力求解"></a>1.暴力求解</h3><p>th:k次决定了移动的次数。每移动一次就动全部元素，因为元素在变化 所有取最后一个元素就可以了。</p>
<p>time : O(k*n) 移动n个元素  k次</p>
<p>space:额外空间o(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> previous=<span class="number">0</span>,temp = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">           previous = nums[nums.length-<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">               temp = nums[j];</span><br><span class="line">               nums[j] = previous;</span><br><span class="line">               previous = temp;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-使用额外的数组"><a href="#2-使用额外的数组" class="headerlink" title="2.使用额外的数组"></a>2.使用额外的数组</h3><p>创建一个新的数组，把移动的元素的位置固定好，关系表达式为 (k+i)%nums.length  </p>
<p>time:O(n)</p>
<p>space:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用额外的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> [] newArr = <span class="keyword">new</span> <span class="keyword">int</span> [nums.length];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           newArr[(i+k)%nums.length] = nums[i];</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           nums[i] = newArr[i];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>还有两个答案 有经历看看</p>
<p><a href="https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode/</a></p>
<h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h2><blockquote>
<p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 num1 成为一个有序数组。</p>
<p>说明:</p>
<p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
<p>示例:</p>
<p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p>
<p>输出: [1,2,2,3,5,6]</p>
</blockquote>
<h3 id="1-合并后在排序"><a href="#1-合并后在排序" class="headerlink" title="1.合并后在排序"></a>1.合并后在排序</h3><p>时间复杂度:O((m+n)log(m+n))</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// nums2 要拷贝的数组 0 开始下标  nums1 拷贝的位置 m 个位置开始 长度为n</span></span><br><span class="line">    System.arraycopy(nums2, <span class="number">0</span>, nums1, m, n);</span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-双指针-从前往后"><a href="#2-双指针-从前往后" class="headerlink" title="2.双指针/从前往后"></a>2.双指针/从前往后</h3><p>时间复杂度:O(m+n)</p>
<p>空间复杂度:O(m)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// Make a copy of nums1.</span></span><br><span class="line">    <span class="keyword">int</span> [] nums1_copy = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    System.arraycopy(nums1, <span class="number">0</span>, nums1_copy, <span class="number">0</span>, m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Two get pointers for nums1_copy and nums2.</span></span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set pointer for nums1</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compare elements from nums1_copy and nums2</span></span><br><span class="line">    <span class="comment">// and add the smallest one into nums1.</span></span><br><span class="line">    <span class="keyword">while</span> ((p1 &lt; m) &amp;&amp; (p2 &lt; n))</span><br><span class="line">      nums1[p++] = (nums1_copy[p1] &lt; nums2[p2]) ? nums1_copy[p1++] : nums2[p2++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if there are still elements to add</span></span><br><span class="line">    <span class="keyword">if</span> (p1 &lt; m)</span><br><span class="line">      System.arraycopy(nums1_copy, p1, nums1, p1 + p2, m + n - p1 - p2);</span><br><span class="line">    <span class="keyword">if</span> (p2 &lt; n)</span><br><span class="line">      System.arraycopy(nums2, p2, nums1, p1 + p2, m + n - p1 - p2);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-双指针-从后往前"><a href="#3-双指针-从后往前" class="headerlink" title="3.双指针/从后往前"></a>3.双指针/从后往前</h3><p>time:O(m+n)</p>
<p>space:O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// two get pointers for nums1 and nums2</span></span><br><span class="line">    <span class="keyword">int</span> p1 = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// set pointer for nums1</span></span><br><span class="line">    <span class="keyword">int</span> p = m + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while there are still elements to compare</span></span><br><span class="line">    <span class="keyword">while</span> ((p1 &gt;= <span class="number">0</span>) &amp;&amp; (p2 &gt;= <span class="number">0</span>))</span><br><span class="line">      <span class="comment">// compare two elements from nums1 and nums2 </span></span><br><span class="line">      <span class="comment">// and add the largest one in nums1 </span></span><br><span class="line">      nums1[p--] = (nums1[p1] &lt; nums2[p2]) ? nums2[p2--] : nums1[p1--];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add missing elements from nums2</span></span><br><span class="line">    System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, p2 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="66-加1"><a href="#66-加1" class="headerlink" title="66.加1"></a>66.加1</h2><blockquote>
<p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p>示例 1:</p>
<p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。<br>示例 2:</p>
<p>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p>
</blockquote>
<p>th:</p>
<p>一共三种情况 </p>
<p>​    1.不存在进位  123  -》 124 </p>
<p>​    2.数字长度不变  199  -&gt; 200  </p>
<p>​    3.数字长度加1   99  -》 100</p>
<p>​    而前两种情况就在for循环中就可以解决了</p>
<p>​    第三种 创建一个新数组，长度加1  默认为0  第一个元素赋值0 </p>
<p>time:O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   一共三种情况 </span></span><br><span class="line"><span class="comment">   1.不存在进位  123  -》 124 </span></span><br><span class="line"><span class="comment">   2.数字长度不变  199  -&gt; 200  </span></span><br><span class="line"><span class="comment">   3.数字长度加1   99  -》 100</span></span><br><span class="line"><span class="comment">   而前两种情况就在for循环中就可以解决了</span></span><br><span class="line"><span class="comment">   第三种 创建一个新数组，长度加1  默认为0  第一个元素赋值0  </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = digits.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           digits[i]++;</span><br><span class="line">           digits[i] = digits[i] %<span class="number">10</span>;</span><br><span class="line">           <span class="keyword">if</span>(digits[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> digits;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> [] newArr = <span class="keyword">new</span> <span class="keyword">int</span> [digits.length+<span class="number">1</span>];</span><br><span class="line">       newArr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> newArr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>第二种答案 思想和上面的一致</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = digits.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length-<span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((digits[i]++)&lt;<span class="number">9</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        digits = <span class="keyword">new</span> <span class="keyword">int</span> [length+<span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By qxlx</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>